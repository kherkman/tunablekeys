<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tunable Keyboard, Sequencer & Drums</title>
    <!-- Link to the external stylesheet -->
    <link rel="stylesheet" href="style.css">
</head>
<body class="skin-dark-space">

    <div class="piano-container">
        <!-- ADDED: Fullscreen close button, hidden by default -->
        <button id="close-fullscreen-btn" class="control-button" style="display: none;">&times;</button>

        <div class="main-instrument-area">
            <div class="root-selector">
                <!-- Root note buttons will be generated here -->
            </div>
            <div class="keys-area">
                <div class="piano-title">Microtonal Keyboard & Sequencer</div>

                <!-- ADDED: This section is now collapsible -->
                <details class="collapsible-section" open>
                    <summary class="collapsible-section-summary">Custom Root Note Tuning</summary>
                    <div id="root-tuning-controls" style="display: flex; flex-wrap: wrap; gap: 10px; padding: 10px; justify-content: center; background-color: var(--bg-control-row); border-radius: 6px;">
                        <!-- Inputs and buttons will be generated here by JS -->
                    </div>
                </details>

                <!-- ADDED: This entire section is now collapsible -->
                <details class="collapsible-section" open>
                    <summary class="collapsible-section-summary" style="font-size: 1.1em;">Instrument Setup</summary>
                    <div class="instrument-config-row">
                         <div class="control-group">
                            <label for="num-piano-keys-input">Number of Slots:</label>
                            <input type="number" id="num-piano-keys-input" value="13" min="1" max="61">
                            <button id="apply-piano-keys-btn" class="control-button" style="font-size:0.8em; padding: 5px 8px;">Apply Slots</button>
                        </div>
                        <div class="control-group">
                            <label for="max-keys-per-row-input">Max Keys/Row:</label>
                            <input type="number" id="max-keys-per-row-input" value="13" min="1" max="25">
                            <button id="apply-max-keys-row-btn" class="control-button" style="font-size:0.8em; padding: 5px 8px;">Apply Layout</button>
                        </div>
                        <div class="control-group">
                            <label for="edo-input">EDO:</label>
                            <input type="number" id="edo-input" value="12" min="1" max="100">
                            <button id="apply-edo-btn" class="control-button" style="font-size:0.8em; padding: 5px 8px;">Apply EDO</button>
                        </div>
                         <div class="control-group">
                            <button id="toggle-key-edit-btn" class="control-button" style="font-size:0.8em; padding: 5px 8px;">Key Edit: Off</button>
                            <button id="toggle-row-stagger-btn" class="control-button" style="font-size:0.8em; padding: 5px 8px;">Stagger: Off</button>
                            <!-- MODIFIED: "Root: Static/Dynamic" button has been moved to the Custom Root Note Tuning section -->
                            <button id="toggle-frequency-display-btn" class="control-button" style="font-size:0.8em; padding: 5px 8px;">Display Freq: Off</button>
                        </div>
                    </div>
                </details>

                <!-- ADDED: This entire section is now collapsible -->
                <details class="collapsible-section" open>
                    <summary class="collapsible-section-summary" style="font-size: 1.1em;">Global & Sound Controls</summary>
                    <div class="global-controls-row">
                         <div class="control-group">
                            <label for="skin-select">Skin:</label>
                            <select id="skin-select">
                                <option value="skin-dark-space">Dark Space</option>
                                <option value="skin-vintage-cream">Vintage Cream</option>
                                <option value="skin-neon-wave">Neon Wave</option>
                                <option value="skin-minimalist-light">Minimalist Light</option>
                                <option value="skin-forest-grove">Forest Grove</option>
                                <option value="skin-oceanic-deep">Oceanic Deep</option>
                            </select>
                        </div>
                         <div class="control-group">
                            <label for="key-shape-select">Key Shape:</label>
                            <select id="key-shape-select">
                                <option value="shape-rectangle">Rectangle</option>
                                <option value="shape-square">Square</option>
                                <option value="shape-circle">Circle</option>
                                <option value="shape-hexagon">Hexagon</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label for="keys-volume-slider">Keys Vol:</label>
                            <input type="range" id="keys-volume-slider" min="0" max="1" value="0.7" step="0.01">
                        </div>
                         <div class="control-group">
                            <label for="sound-type-keys-select">Keys Sound:</label>
                            <select id="sound-type-keys-select">
                                <!-- Options will be populated by JavaScript -->
                            </select>
                        </div>
                        <div class="control-group">
                            <label for="sequencer-volume-slider">Seq Vol:</label>
                            <input type="range" id="sequencer-volume-slider" min="0" max="1" value="0.7" step="0.01">
                        </div>
                         <div class="control-group">
                            <label for="sound-type-seq-select">Seq Sound (Melodic):</label>
                             <select id="sound-type-seq-select">
                                <!-- Options will be populated by JavaScript -->
                            </select>
                        </div>
                         <div class="control-group">
                            <button id="export-sound-definitions-btn" class="control-button" style="font-size:0.8em; padding: 5px 8px;">Export Sound Code</button>
                            <input type="file" id="import-sound-definitions-input" accept=".js,.txt" style="display: none;">
                            <button id="import-sound-definitions-btn" class="control-button" style="font-size:0.8em; padding: 5px 8px;">Import Sound Code</button>
                        </div>
                        <div class="control-group">
                            <label for="midi-in-select">MIDI In:</label>
                            <select id="midi-in-select"><option value="">(No devices)</option></select>
                            <button id="midi-in-toggle-btn" class="control-button" style="font-size:0.8em; padding: 5px 8px;">Off</button>
                        </div>
                        <div class="control-group">
                            <label for="midi-out-select">MIDI Out:</label>
                            <select id="midi-out-select"><option value="">(No devices)</option></select>
                            <button id="midi-out-toggle-btn" class="control-button" style="font-size:0.8em; padding: 5px 8px;">Off</button>
                        </div>
                         <div class="control-group">
                            <label for="midi-mod-wheel-select">Mod Wheel:</label>
                            <select id="midi-mod-wheel-select">
                                <option value="none">None</option>
                                <option value="keys_vol">Keys Volume</option>
                                <option value="seq_vol">Sequencer Volume</option>
                                <option value="tempo">Tempo</option>
                                <option value="pitch">Global Pitch</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <button id="mute-all-btn" class="control-button" style="background-color: #c0392b; color: white;">Mute All</button>
                             <!-- ADDED: Fullscreen Button -->
                            <button id="toggle-fullscreen-btn" class="control-button">Full Screen Keys</button>
                        </div>
                    </div>
                </details>

                <!-- ADDED: This entire section is now collapsible -->
                <details class="collapsible-section" open>
                    <summary class="collapsible-section-summary" style="font-size: 1.1em;">Keyboard Display & Pitch</summary>
                    <div class="controls-waveform-container">
                        <div class="top-controls-row">
                            <div class="octave-controls">
                                <button id="octave-down-btn" class="control-button">&ndash; Oct</button>
                                <span id="octave-display">Oct: 0</span>
                                <button id="octave-up-btn" class="control-button">+ Oct</button>
                            </div>
                             <div class="pitch-controls">
                                <label for="pitch-shift-slider">Pitch:</label>
                                <input type="range" id="pitch-shift-slider" min="-2" max="2" value="0" step="0.01">
                                <span id="pitch-shift-display">0.00 st</span>
                            </div>
                            <div class="zoom-controls">
                                <label for="zoom-slider">Zoom:</label>
                                <input type="range" id="zoom-slider" min="40" max="120" value="65" step="5">
                            </div>
                        </div>
                        <canvas id="waveform-canvas"></canvas>
                        <div id="interval-display-line-container" style="display: none;">
                            <div id="interval-display-line"></div>
                        </div>
                    </div>
                </details>
                <div class="keys-scroller">
                    <div class="piano-keys-container" id="piano-keys-container">
                        <!-- Piano key rows will be generated here -->
                    </div>
                </div>
            </div>
        </div>

        <details class="collapsible-section" open>
            <summary class="collapsible-section-summary">Chord & Arpeggio Controls</summary>
            <div class="chord-controls-container">
                <div class="chord-config-row">
                     <div class="control-group">
                        <label for="num-chords-input">Number of Chords:</label>
                        <input type="number" id="num-chords-input" value="4" min="1" max="10">
                        <button id="apply-num-chords-btn" class="control-button" style="font-size:0.8em; padding: 5px 8px;">Apply Chords</button>
                    </div>
                </div>
                <div class="chord-buttons-row" id="chord-buttons-row">
                    <!-- Chord definition groups will be generated here by JS -->
                </div>
                <button id="arp-toggle-btn" class="control-button">Arp: Off</button>
            </div>
        </details>

        <details class="collapsible-section" open>
            <summary class="collapsible-section-summary">Sequencer & Drums</summary>
            <div class="sequencer-section">
                <div class="sequencer-title">Dynamic Row Sequencer + Drums</div>
                <div class="sequencer-main-controls">
                    <button id="seq-play-stop-btn" class="control-button">Play</button>
                    <label for="seq-tempo-slider">Tempo:</label>
                    <input type="range" id="seq-tempo-slider" min="30" max="280" value="120" step="1">
                    <span id="seq-tempo-display">120 BPM</span>
                    <input type="number" id="seq-tempo-input" value="120" min="20" max="300" title="Tempo BPM">
                    <button id="tap-tempo-btn" class="control-button">Tap Tempo</button>
                    
                    <label for="num-seq-steps-input">Steps:</label>
                    <input type="number" id="num-seq-steps-input" value="16" min="4" max="64" step="1">
                    <button id="apply-seq-steps-btn" class="control-button" style="font-size:0.8em; padding: 5px 8px;">Apply Steps</button>
                    <label for="num-seq-rows-input">Melodic Rows:</label>
                    <input type="number" id="num-seq-rows-input" value="4" min="0" max="13"> 
                    <button id="apply-seq-rows-btn" class="control-button" style="font-size:0.8em; padding: 5px 8px;">Apply Rows</button>
                </div>
                <div class="sequencer-grid-container" id="sequencer-grid">
                    <!-- Sequencer rows/steps will be generated here -->
                </div>
                <div class="sequencer-file-ops">
                    <button id="save-sequence-btn" class="control-button">Save Session</button>
                    <input type="file" id="load-sequence-input" accept=".json" style="display: none;">
                    <button id="load-sequence-btn" class="control-button">Load Session</button>
                    <button id="export-midi-btn" class="control-button">Export MIDI</button>
                </div>
            </div>
        </details>
    </div>

    <!-- Load the sound definition script BEFORE the main script -->
    <script src="sound-definitions.js"></script>
    
    <!-- Load the NEW sequencer/drum script BEFORE the main script -->
    <script src="sequencer-drums.js"></script>
    
    <!-- Load the NEW chord/arpeggio script BEFORE the main script -->
    <script src="chords-arpeggio.js"></script>

    <!-- Load the NEW audio/midi script BEFORE the main script -->
    <script src="audio-midi.js"></script>

    <script>
        const NOTE_NAMES = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        const BASE_FREQUENCIES_C4_OCTAVE = { // Used as a fallback and for initial C4 frequency
            "C": 261.63, "C#": 277.18, "D": 293.66, "D#": 311.13, "E": 329.63, 
            "F": 349.23, "F#": 369.99, "G": 392.00, "G#": 415.30, "A": 440.00, 
            "A#": 466.16, "B": 493.88
        };
        const JUST_INTONATION_RATIOS = [
            1/1,     // C
            16/15,   // C#/Db
            9/8,     // D
            6/5,     // D#/Eb
            5/4,     // E
            4/3,     // F
            45/32,   // F#/Gb
            3/2,     // G
            8/5,     // G#/Ab
            5/3,     // A
            16/9,    // A#/Bb
            15/8     // B
        ];
        const DEFAULT_INTERVAL_RATIOS = [ 
            "1/1", "16/15", "9/8", "6/5", "5/4", "4/3", "45/32", 
            "3/2", "8/5", "5/3", "16/9", "15/8" 
        ]; 
        let keysData = []; 

        let currentRootNoteName = "C";
        let currentRootFrequency = BASE_FREQUENCIES_C4_OCTAVE["C"];
        let NUM_PIANO_KEYS = 13; 
        let currentMaxKeysPerRow = 13; 

        let rootCFrequency = BASE_FREQUENCIES_C4_OCTAVE["C"];
        let masterRootNoteRatios = [...JUST_INTONATION_RATIOS];
        let rootNoteRatios = [...masterRootNoteRatios];
        let currentBaseFrequencies = { ...BASE_FREQUENCIES_C4_OCTAVE };
        let isRootDynamic = false;

        const rootSelectorDiv = document.querySelector('.root-selector');
        const pianoKeysContainerDiv = document.getElementById('piano-keys-container'); 
        const zoomSlider = document.getElementById('zoom-slider');
        
        let currentOctaveOffset = 0;
        const MIN_OCTAVE_OFFSET = -2;
        const MAX_OCTAVE_OFFSET = 2;
        let octaveUpBtn, octaveDownBtn, octaveDisplaySpan;

        let globalPitchShiftSemitones = 0;
        let pitchShiftSlider, pitchShiftDisplay;

        let intervalDisplayLineContainer;

        // Sequencer and Drum variables remain here to be globally accessible
        const NUM_DRUM_ROWS = 3;
        const DRUM_ROW_NAMES = ["Kick", "Snare", "Hi-Hat"]; 
        const DRUM_WAV_FILES = ["kick.wav", "snare.wav", "hi-hat.wav"];
        const DRUM_FALLBACK_SYNTHS = ["kick_drum", "synth_snare", "hi_hat_noise"]; 
        const drumSamples = { "Kick": null, "Snare": null, "Hi-Hat": null };
        const DRUM_SAMPLES_PATH = ""; 
        let NUM_SEQ_MELODIC_ROWS = 4; 
        let NUM_SEQ_STEPS = 16; 
        let sequencerData = Array(NUM_DRUM_ROWS + NUM_SEQ_MELODIC_ROWS).fill(null).map(() => Array(NUM_SEQ_STEPS).fill(false));
        let SEQ_ROW_KEY_INDICES = Array(NUM_SEQ_MELODIC_ROWS).fill(0).map((_, i) => i % (NUM_PIANO_KEYS || 1)); 
        let currentSeqTempoBPM = 120;
        let isSequencerPlaying = false;
        let currentSeqStep = 0;
        let seqIntervalId = null;
        let lastTapTime = 0;
        let tapTempoCount = 0;
        let seqPlayStopBtn, seqTempoSlider, seqTempoDisplay, seqTempoInput, tapTempoBtn;
        let numSeqStepsInput, applySeqStepsBtn;
        let numSeqRowsInput, applySeqRowsBtn; 
        let sequencerGridDiv;
        
        // Piano sample variables are now declared in sound-definitions.js
        // but we need to manage the audio buffers here.
        const PIANO_WAV_FILES = ["A2sound.wav", "A2sound2.wav", "A2sound3.wav", "A2sound4.wav"];
        const PIANO_SAMPLES_PATH = "";

        let currentSoundTypeKeys = 'piano_wav';
        let currentSoundTypeSeq = 'pluck_saw'; 

        let numPianoKeysInput, applyPianoKeysBtn;
        let maxKeysPerRowInput, applyMaxKeysRowBtn; 
        
        let keysVolumeSlider, sequencerVolumeSlider;
        let soundTypeKeysSelect, soundTypeSeqSelect;
        let exportSoundDefsBtn, importSoundDefsInput, importSoundDefsBtn;
        
        let skinSelect, keyShapeSelect, edoInput, applyTuningBtn;
        let currentSkin = 'skin-dark-space';
        let currentKeyShape = 'shape-rectangle';
        let draggedKeyIndex = null;
        
        let isKeyEditMode = false;
        let areRowsStaggered = false;
        let isEdoModeActive = false;
        let isFrequencyDisplayed = false;

        let soundDefinitionFunctionBody = ''; // Will be populated by the function from the external file
        let currentSoundGenerator;

        const activeKeyboardNotes = {}; 
        const ROOT_NOTE_KEY_MAP = { 
            '1':'C', '2':'C#', '3':'D', '4':'D#', '5':'E', '6':'F', 
            '7':'F#', '8':'G', '9':'G#', '0':'A', '=':'A#', '?':'B' 
        };
        const PIANO_KEY_COMPUTER_KEY_MAP = [ 
            'q','w','e','r','t','y','u','i','o','p',
            'a','s','d','f','g','h','j','k','l',
            'z','x','c','v','b','n','m',',','.'
        ];

        function gcd(a, b) { 
            a = Math.abs(Math.round(a)); 
            b = Math.abs(Math.round(b));
            if (b === 0) return a;
            return gcd(b, a % b);
        }
        
        function decimalToFractionString(decimal, maxDenominator = 256) {
            if (decimal === undefined || isNaN(decimal)) return "1/1"; 
            if (decimal % 1 === 0 && decimal !== 0) return `${decimal}/1`;
            if (decimal === 0) return "0/1";

            let bestN = Math.round(decimal * maxDenominator);
            let bestD = maxDenominator;
            let minError = Infinity;

            for (let d_try = 1; d_try <= maxDenominator; d_try++) {
                const n_try = Math.round(decimal * d_try);
                if (n_try === 0 && Math.abs(decimal) > 1e-9) continue; 
                
                const currentError = Math.abs(decimal - n_try / d_try);
                if (currentError < minError) {
                    minError = currentError;
                    bestN = n_try;
                    bestD = d_try;
                }
                if (minError < 1e-9) break; 
            }
            const common = gcd(bestN, bestD);
            const finalN = bestN / common;
            const finalD = bestD / common;

            if (finalD === 1) return `${finalN}`; 
            return `${finalN}/${finalD}`;
        }
        
        function getEffectiveIntervalString(keyIndex) {
            if (keyIndex < 0 || keyIndex >= keysData.length || !keysData[keyIndex]) {
                return "1/1";
            }
            const baseIntervalStrForKey = keysData[keyIndex].interval || "1/1";
            
            let n_str, d_str;
            const parts = baseIntervalStrForKey.split('/');
            if (parts.length === 1) { n_str = parts[0]; d_str = "1"; }
            else if (parts.length === 2) { n_str = parts[0]; d_str = parts[1]; }
            else { n_str = "1"; d_str = "1"; } 

            let n = parseFloat(n_str);
            let d = parseFloat(d_str);
            if (isNaN(n) || isNaN(d) || d === 0) { n = 1; d = 1; }

            // MODIFIED: Do not apply implicit octave shifts when in EDO mode,
            // as the interval is absolute from the root.
            const implicitOctaveShift = isEdoModeActive ? 0 : Math.floor(keyIndex / 12);
            const totalOctaveShift = implicitOctaveShift + currentOctaveOffset;

            if (totalOctaveShift > 0) { n *= Math.pow(2, totalOctaveShift); }
            else if (totalOctaveShift < 0) { d *= Math.pow(2, -totalOctaveShift); }

            let tempN = n;
            let tempD = d;
            let factor = 1;
            while( (tempN % 1 !== 0 || tempD % 1 !== 0) && factor < 100000 ) {
                factor *= 10;
                tempN = n * factor;
                tempD = d * factor;
            }
            n = Math.round(tempN);
            d = Math.round(tempD);

            const commonDivisor = gcd(n, d);
            let final_n = n / commonDivisor;
            let final_d = d / commonDivisor;

            if (final_d < 0) { final_n = -final_n; final_d = -final_d; } 

            return (final_d === 1) ? `${final_n}` : `${final_n}/${final_d}`;
        }

        // loadDrumSamples function is now in sequencer-drums.js

        function parseRatio(ratioStr) {
            if (typeof ratioStr !== 'string') return 1;
            if (ratioStr.includes('/')) {
                const parts = ratioStr.split('/');
                const num = parseFloat(parts[0]);
                const den = parseFloat(parts[1]);
                if (den === 0 || isNaN(num) || isNaN(den)) return 1;
                return num / den;
            }
            const val = parseFloat(ratioStr);
            return isNaN(val) ? 1 : val;
        }

        function getFrequencyForKey(keyIndex, octaveModifier = 0) {
            if (keyIndex < 0 || keyIndex >= NUM_PIANO_KEYS || !keysData[keyIndex]) return null;
            
            const baseIntervalStringForKey = keysData[keyIndex].interval || DEFAULT_INTERVAL_RATIOS[keyIndex % DEFAULT_INTERVAL_RATIOS.length];
            const intervalRatio = parseRatio(baseIntervalStringForKey);
            
            // MODIFIED: Do not apply implicit octave shifts when in EDO mode,
            // as the interval is absolute from the root.
            const implicitOctaveShift = isEdoModeActive ? 0 : Math.floor(keyIndex / 12); 
            const baseFrequencyForKey = currentRootFrequency * intervalRatio;
            
            const octaveShiftedFreq = baseFrequencyForKey * Math.pow(2, currentOctaveOffset + octaveModifier + implicitOctaveShift);
            const finalFreq = octaveShiftedFreq * Math.pow(2, globalPitchShiftSemitones / 12);
            
            return {
                finalFreq: finalFreq,
                baseFreq: octaveShiftedFreq
            };
        }

        function applyZoom(keyWidthValue) {
            const numKeyWidth = parseFloat(keyWidthValue);
            document.documentElement.style.setProperty('--key-width', `${numKeyWidth}px`);
            document.querySelectorAll('.piano-key').forEach(key => {
                key.style.width = `${numKeyWidth}px`;
            });
            document.querySelectorAll('.interval-input').forEach(input => {
                const newIntervalInputWidth = Math.max(30, Math.min(numKeyWidth - 10, 55));
                input.style.width = `${newIntervalInputWidth}px`;
            });
            document.querySelectorAll('.midi-note-input').forEach(input => {
                const newMidiInputWidth = Math.max(30, Math.min(numKeyWidth - 20, 45));
                input.style.width = `${newMidiInputWidth}px`;
            });
        }
        
        function updateOctaveDisplay() {
            if (!octaveDisplaySpan || !octaveUpBtn || !octaveDownBtn) return;
            octaveDisplaySpan.textContent = `Oct: ${currentOctaveOffset >= 0 ? '+' : ''}${currentOctaveOffset}`;
            octaveUpBtn.disabled = currentOctaveOffset >= MAX_OCTAVE_OFFSET;
            octaveDownBtn.disabled = currentOctaveOffset <= MIN_OCTAVE_OFFSET;
            updateKeyDisplays(); 
            for (const chordType in chordDefinitions) {
                createChordKeySelectors(chordType);
            }
        }
        
        let keyIdCounter = 0;
        function generateKeyId() {
            return Date.now() + (keyIdCounter++);
        }
        
        function resizeKeyDataArray() {
            const oldKeysData = [...keysData];
            keysData = [];
            for (let i = 0; i < NUM_PIANO_KEYS; i++) {
                if (i < oldKeysData.length) {
                    if (oldKeysData[i] && typeof oldKeysData[i].midiNote === 'undefined') {
                        oldKeysData[i].midiNote = 60 + i;
                    }
                    keysData.push(oldKeysData[i]);
                } else {
                    keysData.push({
                        id: generateKeyId(),
                        interval: DEFAULT_INTERVAL_RATIOS[i % DEFAULT_INTERVAL_RATIOS.length],
                        midiNote: 60 + i 
                    });
                }
            }
        }

        function handleApplyPianoKeys() {
            const newNumKeys = parseInt(numPianoKeysInput.value, 10);
            if (isNaN(newNumKeys) || newNumKeys < 1 || newNumKeys > 61) { 
                alert("Number of key slots must be between 1 and 61.");
                numPianoKeysInput.value = NUM_PIANO_KEYS; 
                return;
            }
            NUM_PIANO_KEYS = newNumKeys;
            resizeKeyDataArray(); 

            remapAllIndices(NUM_PIANO_KEYS > 0 ? NUM_PIANO_KEYS - 1 : -1);
            
            createPianoKeysAndRootSelector(); 
            createSequencerGrid(); 
            updateKeyDisplays(); 
        }

        function remapAllIndices(maxIndex) {
            for (const type in chordDefinitions) {
                if (chordDefinitions[type]) {
                     chordDefinitions[type].currentKeyIndices = chordDefinitions[type].currentKeyIndices.map(ki => {
                        if (ki === null) return null; 
                        let newIndexValue;
                        if (typeof ki === 'object') { 
                            newIndexValue = Math.max(0, Math.min(ki.keyIndex, maxIndex));
                            return { ...ki, keyIndex: newIndexValue };
                        } else { 
                            newIndexValue = Math.max(0, Math.min(ki, maxIndex));
                            return newIndexValue;
                        }
                    }).slice(0, chordDefinitions[type].numNotes);
                    createChordKeySelectors(type); 
                }
            }

            SEQ_ROW_KEY_INDICES = SEQ_ROW_KEY_INDICES.map(idx => Math.min(idx, maxIndex));
        }


        function handleApplyMaxKeysPerRow() {
            const newMax = parseInt(maxKeysPerRowInput.value, 10);
            if (isNaN(newMax) || newMax < 1 || newMax > 25) { 
                alert("Max keys per row must be between 1 and 25.");
                maxKeysPerRowInput.value = currentMaxKeysPerRow;
                return;
            }
            currentMaxKeysPerRow = newMax;
            createPianoKeysAndRootSelector(); 
        }

        function createPianoKeysAndRootSelector() {
            rootSelectorDiv.innerHTML = ''; 
            NOTE_NAMES.forEach(noteName => {
                const button = document.createElement('button');
                button.classList.add('root-button');
                button.textContent = noteName;
                button.dataset.noteName = noteName;
                if (noteName === currentRootNoteName) button.classList.add('active');
                button.addEventListener('click', (e) => {
                    selectRootNote(noteName, e.target);
                });
                rootSelectorDiv.appendChild(button);
            });

            pianoKeysContainerDiv.innerHTML = ''; 
            if (keysData.length !== NUM_PIANO_KEYS) { 
                resizeKeyDataArray();
            }

            let currentKeyRowDiv;
            for (let i = 0; i < NUM_PIANO_KEYS; i++) {
                if (i % currentMaxKeysPerRow === 0) { 
                    currentKeyRowDiv = document.createElement('div');
                    currentKeyRowDiv.classList.add('piano-keys-row');
                    pianoKeysContainerDiv.appendChild(currentKeyRowDiv);
                }

                const keyData = keysData[i];
                if (keyData === null) {
                    const placeholder = document.createElement('div');
                    placeholder.classList.add('key-placeholder');
                    placeholder.dataset.keyIndex = i;
                    placeholder.textContent = '+';
                    placeholder.title = 'Empty Slot - Click to add a key';
                    placeholder.addEventListener('dragover', handleDragOver);
                    placeholder.addEventListener('dragleave', handleDragLeave);
                    placeholder.addEventListener('drop', handleDrop);
                    placeholder.addEventListener('dragend', handleDragEnd);
                    placeholder.addEventListener('click', () => {
                        if (isKeyEditMode) {
                            handleAddKey(i);
                        }
                    });
                    currentKeyRowDiv.appendChild(placeholder);
                    continue; 
                }

                const keyWrapper = document.createElement('div');
                keyWrapper.classList.add('key-wrapper');
                keyWrapper.dataset.keyIndex = i;
                
                keyWrapper.draggable = isKeyEditMode;
                keyWrapper.addEventListener('dragstart', handleDragStart);
                keyWrapper.addEventListener('dragover', handleDragOver);
                keyWrapper.addEventListener('dragleave', handleDragLeave);
                keyWrapper.addEventListener('drop', handleDrop);
                keyWrapper.addEventListener('dragend', handleDragEnd);

                const midiInput = document.createElement('input');
                midiInput.type = 'number';
                midiInput.min = 0;
                midiInput.max = 127;
                midiInput.title = 'MIDI Note';
                midiInput.classList.add('midi-note-input');
                midiInput.dataset.keyIndex = i;
                midiInput.addEventListener('change', (event) => {
                    const keyIndex = parseInt(event.target.dataset.keyIndex, 10);
                    const newMidiNote = parseInt(event.target.value, 10);
                    if (!isNaN(newMidiNote) && newMidiNote >= 0 && newMidiNote <= 127) {
                        if (keysData[keyIndex]) {
                            keysData[keyIndex].midiNote = newMidiNote;
                        }
                    } else {
                        alert("MIDI note must be between 0 and 127.");
                        event.target.value = keysData[keyIndex].midiNote; // Revert
                    }
                });


                const intervalInput = document.createElement('input');
                intervalInput.type = 'text';
                intervalInput.classList.add('interval-input');
                intervalInput.dataset.keyIndex = i;

                intervalInput.addEventListener('change', (event) => {
                    const inputEl = event.target;
                    const keyIndex = parseInt(inputEl.dataset.keyIndex);
                    const newEffectiveRatioStr = inputEl.value; 

                    let effN_str, effD_str;
                    const effParts = newEffectiveRatioStr.split('/');
                    if (effParts.length === 1) { effN_str = effParts[0]; d_str = "1"; }
                    else if (effParts.length === 2) { effN_str = effParts[0]; d_str = effParts[1]; }
                    else { alert("Invalid ratio format. Use 'N' or 'N/D'."); updateKeyDisplays(); return; } 

                    let effN = parseFloat(effN_str);
                    let effD = parseFloat(d_str);

                    if (isNaN(effN) || isNaN(effD) || effD === 0) {
                        alert("Invalid numbers in ratio."); updateKeyDisplays(); return; 
                    }
                    const effectiveNumericRatio = effN / effD;
                    const implicitOctaveShift = isEdoModeActive ? 0 : Math.floor(keyIndex / 12);
                    const totalAppliedOctaveShift = implicitOctaveShift + currentOctaveOffset;

                    let baseNumericRatio = effectiveNumericRatio;
                    if (totalAppliedOctaveShift > 0) {
                        baseNumericRatio /= Math.pow(2, totalAppliedOctaveShift);
                    } else if (totalAppliedOctaveShift < 0) {
                        baseNumericRatio *= Math.pow(2, -totalAppliedOctaveShift);
                    }
                    if (keysData[keyIndex]) {
                        keysData[keyIndex].interval = decimalToFractionString(baseNumericRatio);
                    }
                    updateKeyDisplays(); 
                });
                
                const key = document.createElement('button');
                key.classList.add('piano-key');
                key.dataset.keyIndex = i;
                const noteNameSpan = document.createElement('span');
                noteNameSpan.classList.add('note-name');
                const intervalDisplaySpan = document.createElement('span');
                intervalDisplaySpan.classList.add('interval-display');
                const frequencyDisplaySpan = document.createElement('span');
                frequencyDisplaySpan.classList.add('frequency-display');

                key.appendChild(noteNameSpan);
                key.appendChild(intervalDisplaySpan);
                key.appendChild(frequencyDisplaySpan);
                
                const playNoteHandler = async () => {
                    await initAudioContext(); 
                    const keyIndex = parseInt(key.dataset.keyIndex);
                    const freqObject = getFrequencyForKey(keyIndex);
                    if (freqObject === null) return;
                    playSound(freqObject, `key_${keyIndex}`, 'key');
                    key.classList.add('playing');
                };
                const stopNoteHandler = () => {
                    stopSound(`key_${parseInt(key.dataset.keyIndex)}`);
                    key.classList.remove('playing');
                };
                
                key.addEventListener('mousedown', playNoteHandler);
                key.addEventListener('mouseup', stopNoteHandler);
                key.addEventListener('mouseleave', () => { if (key.classList.contains('playing')) stopNoteHandler(); });
                key.addEventListener('touchstart', (e) => { e.preventDefault(); playNoteHandler(); });
                key.addEventListener('touchend', (e) => { e.preventDefault(); stopNoteHandler(); });
                
                const deleteBtn = document.createElement('button');
                deleteBtn.classList.add('delete-key-btn');
                deleteBtn.innerHTML = '&times;';
                deleteBtn.title = 'Delete Key';
                deleteBtn.dataset.keyIndex = i;
                deleteBtn.addEventListener('click', handleDeleteKey);
                
                keyWrapper.appendChild(midiInput);
                keyWrapper.appendChild(intervalInput);
                keyWrapper.appendChild(key);
                keyWrapper.appendChild(deleteBtn);
                currentKeyRowDiv.appendChild(keyWrapper);
            }
            updateKeyDisplays();
            if (zoomSlider) applyZoom(zoomSlider.value);
            setKeyEditMode(isKeyEditMode); 
        }

        function handleAddKey(keyIndex) {
            keysData[keyIndex] = {
                id: generateKeyId(),
                interval: decimalToFractionString(Math.pow(2, keyIndex / 12)), // Default to 12-EDO for the position
                midiNote: 60 + keyIndex
            };
            createPianoKeysAndRootSelector();
            updateKeyDisplays();
        }

        function handleDeleteKey(event) {
            const keyIndexToDelete = parseInt(event.target.dataset.keyIndex, 10);
            if (keyIndexToDelete === 0) {
                alert("The root key slot (Key 1) cannot be deleted.");
                return;
            }
            if (confirm(`Are you sure you want to delete key ${keyIndexToDelete + 1}? This will create an empty slot.`)) {
                keysData[keyIndexToDelete] = null;
                createPianoKeysAndRootSelector();
                updateKeyDisplays();
            }
        }
        
        function handleDragStart(e) {
            draggedKeyIndex = parseInt(e.target.dataset.keyIndex, 10);
            
            stopSound(`key_${draggedKeyIndex}`);
            stopSound(`keyboard_key_${draggedKeyIndex}`);

            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', draggedKeyIndex);
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            const target = e.target.closest('.key-wrapper, .key-placeholder');
            if (target) {
                target.classList.add('drag-over');
            }
        }
        
        function handleDragLeave(e) {
            const target = e.target.closest('.key-wrapper, .key-placeholder');
            if (target) {
                target.classList.remove('drag-over');
            }
        }

        function handleDrop(e) {
            e.preventDefault();
            const target = e.target.closest('.key-wrapper, .key-placeholder');
            if (target) {
                target.classList.remove('drag-over');
                const targetIndex = parseInt(target.dataset.keyIndex, 10);
                
                if (draggedKeyIndex !== null && draggedKeyIndex !== targetIndex) {
                    const draggedItem = keysData[draggedKeyIndex];
                    keysData[draggedKeyIndex] = keysData[targetIndex];
                    keysData[targetIndex] = draggedItem;
                    
                    createPianoKeysAndRootSelector();
                    updateKeyDisplays();
                }
            }
        }
        
        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            draggedKeyIndex = null;
            document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
        }

        async function selectRootNote(noteName, buttonElement = null) {
            await initAudioContext();

            if (isRootDynamic) {
                const rootIndex = NOTE_NAMES.indexOf(noteName);
                if (rootIndex !== -1) {
                    const newRootRatio = masterRootNoteRatios[rootIndex];
                    rootNoteRatios = masterRootNoteRatios.map(r => r / newRootRatio);
                    recalculateBaseFrequencies();
                    updateRootTuningInputs();
                }
            }

            currentRootNoteName = noteName;
            currentRootFrequency = currentBaseFrequencies[noteName];
            document.querySelectorAll('.root-button.active, .root-button.keyboard-active').forEach(b => {
                b.classList.remove('active');
                b.classList.remove('keyboard-active');
            });
            if (buttonElement) {
                buttonElement.classList.add('active');
            } else { 
                const targetButton = rootSelectorDiv.querySelector(`.root-button[data-note-name="${noteName}"]`);
                if (targetButton) targetButton.classList.add('keyboard-active');
            }
            updateKeyDisplays();
            for (const chordType in chordDefinitions) {
                createChordKeySelectors(chordType);
            }
        }

        function updateKeyDisplays() {
            const rootNoteIndex = NOTE_NAMES.indexOf(currentRootNoteName);
            document.querySelectorAll('.piano-key').forEach((keyElement) => { 
                const keyIndex = parseInt(keyElement.dataset.keyIndex);
                if (keyIndex >= keysData.length || !keysData[keyIndex]) return; 

                const intervalInputEl = document.querySelector(`.interval-input[data-key-index="${keyIndex}"]`);
                const midiInputEl = document.querySelector(`.midi-note-input[data-key-index="${keyIndex}"]`);
                const freqDisplayEl = keyElement.querySelector('.frequency-display');
                if (!intervalInputEl || !midiInputEl || !freqDisplayEl) return;

                midiInputEl.value = keysData[keyIndex].midiNote || (60 + keyIndex);

                const baseIntervalStrForKey = keysData[keyIndex].interval || "1/1";
                
                const baseIntervalForNoteName = parseRatio(baseIntervalStrForKey);
                const displaySemitonesFromRoot = Math.round(12 * Math.log2(baseIntervalForNoteName));
                const noteNameIndex = (rootNoteIndex + displaySemitonesFromRoot + 12 * 10) % 12; 
                const noteName = NOTE_NAMES[noteNameIndex]; 
                keyElement.querySelector('.note-name').textContent = noteName;

                if (noteName.includes("#") || noteName.includes("b")) {
                    keyElement.classList.add('sharp-flat-key');
                } else {
                    keyElement.classList.remove('sharp-flat-key');
                }

                const effectiveIntervalStr = getEffectiveIntervalString(keyIndex);
                intervalInputEl.value = effectiveIntervalStr;
                keyElement.querySelector('.interval-display').textContent = `(${effectiveIntervalStr})`;
                
                if (isFrequencyDisplayed) {
                    const freqObject = getFrequencyForKey(keyIndex);
                    freqDisplayEl.textContent = freqObject ? `${freqObject.finalFreq.toFixed(2)} Hz` : '';
                    freqDisplayEl.style.display = 'block';
                } else {
                    freqDisplayEl.style.display = 'none';
                }
            });
            
            document.querySelectorAll('.seq-row-key-select').forEach(select => {
                const currentVal = parseInt(select.value, 10);
                const melodicRowIndex = parseInt(select.dataset.rowIndex); 
                select.innerHTML = ''; 
                 for (let i = 0; i < NUM_PIANO_KEYS; i++) { 
                    if (!keysData[i]) continue; 
                    const option = document.createElement('option'); option.value = i;
                    const effectiveIntervalForSeqDisp = getEffectiveIntervalString(i); 
                    option.textContent = `Key ${i+1} (${effectiveIntervalForSeqDisp})`; 
                    select.appendChild(option);
                }
                if (keysData[currentVal]) { 
                    select.value = currentVal; 
                } else if (select.options.length > 0) {
                    const firstValidIndex = select.options[0].value;
                    select.value = firstValidIndex;
                    SEQ_ROW_KEY_INDICES[melodicRowIndex] = parseInt(firstValidIndex, 10);
                } else { 
                    select.value = ""; 
                    SEQ_ROW_KEY_INDICES[melodicRowIndex] = undefined;
                }
            });
            updateIntervalDisplayLine();
        }

        function updateIntervalDisplayLine() {
            if (!intervalDisplayLineContainer) return;

            const line = intervalDisplayLineContainer.querySelector('#interval-display-line');
            if (!line) return;
            line.innerHTML = ''; 

            const keyDisplayData = [];
            for (let i = 0; i < NUM_PIANO_KEYS; i++) {
                if (!keysData[i]) continue; 
                const freqObject = getFrequencyForKey(i);
                if (freqObject !== null && freqObject.baseFreq > 0) {
                    keyDisplayData.push({
                        freq: freqObject.baseFreq,
                        ratio: getEffectiveIntervalString(i)
                    });
                }
            }

            if (keyDisplayData.length < 2) {
                intervalDisplayLineContainer.style.display = 'none';
                return;
            }

            intervalDisplayLineContainer.style.display = 'flex';
            
            keyDisplayData.sort((a, b) => a.freq - b.freq);

            const minFreq = keyDisplayData[0].freq;
            const maxFreq = keyDisplayData[keyDisplayData.length - 1].freq;
            
            const minLog = Math.log(minFreq);
            const rangeLog = Math.log(maxFreq) - minLog;

            if (rangeLog <= 0) {
                 intervalDisplayLineContainer.style.display = 'none';
                 return;
            }

            const fragment = document.createDocumentFragment();

            keyDisplayData.forEach(data => {
                const posPercent = ((Math.log(data.freq) - minLog) / rangeLog) * 100;
                
                const marker = document.createElement('div');
                marker.className = 'interval-marker';
                
                const label = document.createElement('div');
                label.className = 'interval-marker-label';
                label.textContent = data.ratio;
                
                const wrapper = document.createElement('div');
                wrapper.style.position = 'absolute';
                wrapper.style.left = `${posPercent}%`;
                wrapper.style.height = '100%';
                wrapper.appendChild(marker);
                wrapper.appendChild(label);
                
                fragment.appendChild(wrapper);
            });
            line.appendChild(fragment);
        }

        function extractSoundNames(codeString) {
            const soundNames = [];
            const regex = /case\s+['"]([^'"]+)['"]\s*:/g;
            let match;
            while ((match = regex.exec(codeString)) !== null) {
                soundNames.push(match[1]);
            }
            return [...new Set(soundNames)]; 
        }

        function updateSoundSelectors(newSoundNames) {
            const selectors = [soundTypeKeysSelect, soundTypeSeqSelect];
            const currentSelections = [currentSoundTypeKeys, currentSoundTypeSeq]; 

            selectors.forEach((select, index) => {
                if (!select) return;
                const previouslySelectedValue = currentSelections[index];
                select.innerHTML = ''; 

                if (newSoundNames.length === 0) {
                     const option = document.createElement('option');
                     option.value = "";
                     option.textContent = "No Sounds Defined";
                     select.appendChild(option);
                } else {
                    newSoundNames.forEach(name => {
                        const option = document.createElement('option');
                        option.value = name;
                        option.textContent = name.charAt(0).toUpperCase() + name.slice(1).replace(/_/g, ' ');
                        select.appendChild(option);
                    });
                }
                
                if (newSoundNames.includes(previouslySelectedValue)) {
                    select.value = previouslySelectedValue;
                } else if (newSoundNames.length > 0) {
                    select.value = newSoundNames[0];
                } else {
                    select.value = ""; 
                }
            });
        }

        function exportSoundDefinitions() {
            const fileContent = `// Custom Sound Definitions for Tunable Keys
// To use, import this file using the "Import Sound Code" button.
// This file should contain ONLY the body of the sound generation function.
// It should start with variable declarations (let mainOsc...) and end with the return statement.
// The file should be named 'sound-definitions.js' and be in the same directory as the HTML file.

${soundDefinitionFunctionBody}
`;
            const blob = new Blob([fileContent], { type: "text/plain" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = "sound-definitions.js";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            alert("Sound definition code exported as sound-definitions.js!");
        }

        function loadSoundDefinitions(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    let newFunctionBodyFromFile = e.target.result;
                    
                    if (!newFunctionBodyFromFile.includes('switch (soundType)')) {
                        throw new Error("Imported file does not appear to contain a valid sound definition structure.");
                    }
                    
                    new Function('soundType', 'frequency', 'now', 'audioContext', 'masterGainNode', 'soundId', 'activeOscillators', newFunctionBodyFromFile); 
                    
                    soundDefinitionFunctionBody = newFunctionBodyFromFile;
                    currentSoundGenerator = new Function('soundType', 'frequency', 'now', 'audioContext', 'masterGainNode', 'soundId', 'activeOscillators', soundDefinitionFunctionBody);
                    
                    const newSoundNames = extractSoundNames(soundDefinitionFunctionBody);
                    if (newSoundNames.length === 0) {
                        alert("Warning: No sound definitions (e.g., 'case \"sound_name\":') found in the imported file.");
                    }
                    
                    updateSoundSelectors(newSoundNames);
                    alert("Sound definitions loaded successfully!");
                } catch (error) {
                    console.error("Error loading sound definitions:", error);
                    alert("Failed to load sound definitions file. Details: " + error.message);
                }
            };
            reader.readAsText(file);
            if (event.target) event.target.value = null; 
        }

        function saveSequence() {
            const savedDrumSamples = {};
            for (const drumName of DRUM_ROW_NAMES) {
                if (drumSamples[drumName]) {
                    savedDrumSamples[drumName] = audioBufferToBase64(drumSamples[drumName]);
                }
            }
            
            const dataToSave = { 
                version: 2.5,
                numPianoKeys: NUM_PIANO_KEYS, 
                currentMaxKeysPerRow: currentMaxKeysPerRow, 
                keysData: keysData, 
                skin: currentSkin,
                keyShape: currentKeyShape,
                numSeqMelodicRows: NUM_SEQ_MELODIC_ROWS, 
                sequencerData: sequencerData, 
                numSeqSteps: NUM_SEQ_STEPS, 
                tempo: currentSeqTempoBPM, 
                rootNote: currentRootNoteName, 
                octaveOffset: currentOctaveOffset,
                seqRowKeyIndices: SEQ_ROW_KEY_INDICES, 
                keysVolume: keysMasterGain ? keysMasterGain.gain.value : 0.7,
                sequencerVolume: sequencerMasterGain ? sequencerMasterGain.gain.value : 0.7, 
                soundTypeKeys: currentSoundTypeKeys, 
                soundTypeSeq: currentSoundTypeSeq,
                soundDefinitionFunctionBody: soundDefinitionFunctionBody,
                numChords: NUM_CHORDS,
                fullChordDefinitions: chordDefinitions,
                savedDrumSamples: savedDrumSamples,
                rootCFrequency: rootCFrequency,
                masterRootNoteRatios: masterRootNoteRatios,
                isRootDynamic: isRootDynamic,
                isKeyEditMode: isKeyEditMode,
                areRowsStaggered: areRowsStaggered,
                modWheelTarget: modWheelTarget,
                isEdoModeActive: isEdoModeActive,
                isFrequencyDisplayed: isFrequencyDisplayed
            };
            const jsonString = JSON.stringify(dataToSave, null, 2); 
            const blob = new Blob([jsonString], { type: "application/json" });
            const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = "tunable_session_v2.5.json"; 
            document.body.appendChild(a);
            a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); alert("Session saved!");
        }

        async function loadSequence(event) { 
            const file = event.target.files[0]; if (!file) return; const reader = new FileReader();
            reader.onload = async (e) => { try { 
                    const loadedData = JSON.parse(e.target.result);

                    if (typeof loadedData.isFrequencyDisplayed === 'boolean') {
                        setFrequencyDisplay(loadedData.isFrequencyDisplayed);
                    }

                    if (loadedData.skin) {
                        applySkin(loadedData.skin);
                        if(skinSelect) skinSelect.value = loadedData.skin;
                    }
                    if (loadedData.keyShape) {
                        applyKeyShape(loadedData.keyShape);
                        if(keyShapeSelect) keyShapeSelect.value = loadedData.keyShape;
                    }

                    if (typeof loadedData.isKeyEditMode === 'boolean') {
                        setKeyEditMode(loadedData.isKeyEditMode);
                    }
                     if (typeof loadedData.areRowsStaggered === 'boolean') {
                        setRowStagger(loadedData.areRowsStaggered);
                    }
                    if (typeof loadedData.modWheelTarget === 'string' && modWheelSelect) {
                        modWheelTarget = loadedData.modWheelTarget;
                        modWheelSelect.value = modWheelTarget;
                    }

                    for (const drumName of DRUM_ROW_NAMES) {
                        drumSamples[drumName] = null;
                    }
                    
                    if (typeof loadedData.rootCFrequency === 'number') {
                        rootCFrequency = loadedData.rootCFrequency;
                    }
                    if (Array.isArray(loadedData.masterRootNoteRatios) && loadedData.masterRootNoteRatios.length === 12) {
                        masterRootNoteRatios = loadedData.masterRootNoteRatios;
                    } else if (Array.isArray(loadedData.rootNoteRatios) && loadedData.rootNoteRatios.length === 12) { // Legacy support
                        masterRootNoteRatios = loadedData.rootNoteRatios;
                    } else {
                        masterRootNoteRatios = [...JUST_INTONATION_RATIOS];
                    }
                    
                    isRootDynamic = !!loadedData.isRootDynamic;
                    const dynamicRootBtn = document.getElementById('toggle-dynamic-root-btn');
                    if (dynamicRootBtn) {
                        dynamicRootBtn.textContent = `Root: ${isRootDynamic ? 'Dynamic' : 'Static'}`;
                        dynamicRootBtn.classList.toggle('active', isRootDynamic);
                    }


                    isEdoModeActive = !!loadedData.isEdoModeActive;
                    if (applyTuningBtn) {
                        applyTuningBtn.textContent = isEdoModeActive ? 'Apply JI' : 'Apply EDO';
                    }
                    
                    rootNoteRatios = [...masterRootNoteRatios]; 
                    generateRootTuningControls();
                    recalculateBaseFrequencies();

                    if (loadedData.keysData && Array.isArray(loadedData.keysData)) {
                        keysData = loadedData.keysData;
                        keysData.forEach((key, i) => {
                            if (key && typeof key.midiNote === 'undefined') {
                                key.midiNote = 60 + i;
                            }
                        });
                        NUM_PIANO_KEYS = keysData.length;
                        if (numPianoKeysInput) numPianoKeysInput.value = NUM_PIANO_KEYS;
                    } else { 
                        NUM_PIANO_KEYS = loadedData.numPianoKeys || 13;
                        if (numPianoKeysInput) numPianoKeysInput.value = NUM_PIANO_KEYS;
                        resizeKeyDataArray();
                        if(loadedData.keyBaseIntervalStrings) {
                           keysData.forEach((key, i) => {
                               if(key && loadedData.keyBaseIntervalStrings[i] !== undefined) {
                                   key.interval = loadedData.keyBaseIntervalStrings[i];
                               }
                           });
                        }
                    }
                    
                    if (typeof loadedData.currentMaxKeysPerRow === 'number') { currentMaxKeysPerRow = loadedData.currentMaxKeysPerRow; if(maxKeysPerRowInput) maxKeysPerRowInput.value = currentMaxKeysPerRow;}
                    else { currentMaxKeysPerRow = 13; if(maxKeysPerRowInput) maxKeysPerRowInput.value = 13;}

                    if (typeof loadedData.numSeqMelodicRows === 'number') { 
                        NUM_SEQ_MELODIC_ROWS = loadedData.numSeqMelodicRows; 
                        if(numSeqRowsInput) numSeqRowsInput.value = NUM_SEQ_MELODIC_ROWS;
                    } else { 
                        NUM_SEQ_MELODIC_ROWS = (typeof loadedData.numSeqRows === 'number') ? loadedData.numSeqRows : 4;
                        if(numSeqRowsInput) numSeqRowsInput.value = NUM_SEQ_MELODIC_ROWS;
                    }

                    await createPianoKeysAndRootSelector(); 

                    if (typeof loadedData.numSeqSteps === 'number') { NUM_SEQ_STEPS = loadedData.numSeqSteps; if(numSeqStepsInput) numSeqStepsInput.value = NUM_SEQ_STEPS; }
                    
                    const totalRowsToLoad = NUM_DRUM_ROWS + NUM_SEQ_MELODIC_ROWS;
                    sequencerData = Array(totalRowsToLoad).fill(null).map((_,r) => {
                        const newRow = Array(NUM_SEQ_STEPS).fill(false);
                        if (loadedData.sequencerData && loadedData.sequencerData[r]) {
                            for (let s = 0; s < Math.min(loadedData.sequencerData[r].length, NUM_SEQ_STEPS); s++) {
                                newRow[s] = loadedData.sequencerData[r][s] || false;
                            }
                        }
                        return newRow;
                    });
                    
                    SEQ_ROW_KEY_INDICES = Array(NUM_SEQ_MELODIC_ROWS); 
                     if (loadedData.seqRowKeyIndices) {
                        for (let i = 0; i < NUM_SEQ_MELODIC_ROWS; i++) {
                            if (i < loadedData.seqRowKeyIndices.length && loadedData.seqRowKeyIndices[i] !== undefined) {
                                const potentialIndex = Math.min(loadedData.seqRowKeyIndices[i], NUM_PIANO_KEYS > 0 ? NUM_PIANO_KEYS - 1 : 0);
                                SEQ_ROW_KEY_INDICES[i] = keysData[potentialIndex] ? potentialIndex : keysData.findIndex(k => k !== null);
                            } else {
                                SEQ_ROW_KEY_INDICES[i] = keysData.findIndex(k => k !== null); 
                            }
                        }
                    } else { 
                         for (let i = 0; i < NUM_SEQ_MELODIC_ROWS; i++) {
                            const firstValidKeyIndex = keysData.findIndex(k => k !== null);
                            SEQ_ROW_KEY_INDICES[i] = firstValidKeyIndex !== -1 ? firstValidKeyIndex : undefined;
                        }
                    }

                    if (loadedData.rootNote && NOTE_NAMES.includes(loadedData.rootNote)) { currentRootNoteName = loadedData.rootNote; }
                    selectRootNote(currentRootNoteName); 
                    
                    if (typeof loadedData.octaveOffset === 'number') { currentOctaveOffset = loadedData.octaveOffset; }
                    
                    if (isSequencerPlaying) stopSequencer(); 
                    
                    if (typeof loadedData.tempo === 'number') {
                        updateSequencerTempo(loadedData.tempo);
                        if(seqTempoSlider) seqTempoSlider.value = loadedData.tempo;
                        if(seqTempoInput) seqTempoInput.value = loadedData.tempo;
                    }

                    createSequencerGrid(); 
                    
                    if (typeof loadedData.keysVolume === 'number' && keysVolumeSlider) { keysVolumeSlider.value = loadedData.keysVolume; if(keysMasterGain) keysMasterGain.gain.value = loadedData.keysVolume; }
                    if (typeof loadedData.sequencerVolume === 'number' && sequencerVolumeSlider) { sequencerVolumeSlider.value = loadedData.sequencerVolume; if(sequencerMasterGain) sequencerMasterGain.gain.value = loadedData.sequencerVolume; }
                    
                    if (typeof loadedData.soundDefinitionFunctionBody === 'string') {
                        try {
                            new Function('soundType', 'frequency', 'now', 'audioContext', 'masterGainNode', 'soundId', 'activeOscillators', loadedData.soundDefinitionFunctionBody);
                            soundDefinitionFunctionBody = loadedData.soundDefinitionFunctionBody;
                            currentSoundGenerator = new Function('soundType', 'frequency', 'now', 'audioContext', 'masterGainNode', 'soundId', 'activeOscillators', soundDefinitionFunctionBody);
                        } catch (synthError) {
                            console.error("Error validating sound definitions from session file:", synthError);
                            alert("Could not load custom sound definitions from session file. Reverting to default. Check console.");
                        }
                    }
                    const soundNamesToList = extractSoundNames(soundDefinitionFunctionBody);
                    updateSoundSelectors(soundNamesToList); 

                    if (loadedData.soundTypeKeys && soundTypeKeysSelect && soundNamesToList.includes(loadedData.soundTypeKeys)) {
                        currentSoundTypeKeys = loadedData.soundTypeKeys; soundTypeKeysSelect.value = currentSoundTypeKeys; 
                    } else if (soundNamesToList.length > 0) { currentSoundTypeKeys = soundNamesToList[0]; soundTypeKeysSelect.value = currentSoundTypeKeys; }

                    if (loadedData.soundTypeSeq && soundTypeSeqSelect && soundNamesToList.includes(loadedData.soundTypeSeq)) { 
                        currentSoundTypeSeq = loadedData.soundTypeSeq; soundTypeSeqSelect.value = currentSoundTypeSeq; 
                    } else if (soundNamesToList.length > 0) { currentSoundTypeSeq = soundNamesToList[0]; soundTypeSeqSelect.value = currentSoundTypeSeq; }

                    if (typeof loadedData.numChords === 'number') {
                        NUM_CHORDS = loadedData.numChords;
                        numChordsInput.value = NUM_CHORDS;
                    }
                    
                    if (loadedData.fullChordDefinitions) {
                        chordDefinitions = loadedData.fullChordDefinitions;
                        for (const type in chordDefinitions) {
                            if (chordDefinitions[type]) {
                                chordDefinitions[type].currentKeyIndices = chordDefinitions[type].currentKeyIndices.map(ki => {
                                    if (ki === null) return null;
                                    let newIndexValue;
                                    if (typeof ki === 'object') {
                                        newIndexValue = Math.max(0, Math.min(ki.keyIndex, NUM_PIANO_KEYS > 0 ? NUM_PIANO_KEYS - 1 : 0));
                                        return { ...ki, keyIndex: newIndexValue };
                                    } else {
                                        newIndexValue = Math.max(0, Math.min(ki, NUM_PIANO_KEYS > 0 ? NUM_PIANO_KEYS - 1 : 0));
                                        return newIndexValue;
                                    }
                                }).slice(0, chordDefinitions[type].numNotes); 
                            }
                        }
                    }
                    rebuildAllChordUIFromDefinitions();

                    if (loadedData.savedDrumSamples) {
                        for (const drumName in loadedData.savedDrumSamples) {
                            if (DRUM_ROW_NAMES.includes(drumName) && loadedData.savedDrumSamples[drumName]) {
                                try {
                                    const buffer = await base64ToAudioBuffer(loadedData.savedDrumSamples[drumName]);
                                    drumSamples[drumName] = buffer;
                                    console.log(`Restored custom drum sample for ${drumName} from file.`);
                                 } catch (e) {
                                    console.error(`Failed to restore custom sample for ${drumName}:`, e);
                                    drumSamples[drumName] = null;
                                }
                            }
                        }
                    }

                    updateOctaveDisplay(); 
                    updateKeyDisplays(); 
                    alert("Session loaded!");
                } catch (error) { console.error("Error loading session:", error); alert("Failed to load session file. Error: " + error.message); }};
            reader.readAsText(file); if(event.target) event.target.value = null; 
        }

        function recalculateBaseFrequencies() {
            currentBaseFrequencies = {};
            for (let i = 0; i < NOTE_NAMES.length; i++) {
                const noteName = NOTE_NAMES[i];
                currentBaseFrequencies[noteName] = rootCFrequency * rootNoteRatios[i];
            }
        }

        function updateRootTuningInputs() {
            const cInput = document.getElementById('root-c-freq-input');
            if (cInput) cInput.value = rootCFrequency.toFixed(2);

            for (let i = 1; i < NOTE_NAMES.length; i++) {
                const input = document.getElementById(`root-ratio-input-${i}`);
                if (input) {
                    input.value = decimalToFractionString(rootNoteRatios[i], 128);
                }
            }
        }

        function generateRootTuningControls() {
            const container = document.getElementById('root-tuning-controls');
            if (!container) return;
            container.innerHTML = '';

            const cGroup = document.createElement('div');
            cGroup.classList.add('control-group');
            const cLabel = document.createElement('label');
            cLabel.htmlFor = 'root-c-freq-input';
            cLabel.textContent = 'C4 Freq (Hz):';
            const cInput = document.createElement('input');
            cInput.type = 'number';
            cInput.id = 'root-c-freq-input';
            cInput.value = rootCFrequency.toFixed(2);
            cInput.style.width = '70px';
            cGroup.appendChild(cLabel);
            cGroup.appendChild(cInput);
            container.appendChild(cGroup);

            for (let i = 1; i < NOTE_NAMES.length; i++) {
                const noteName = NOTE_NAMES[i];
                const group = document.createElement('div');
                group.classList.add('control-group');
                const label = document.createElement('label');
                label.htmlFor = `root-ratio-input-${i}`;
                label.textContent = `${noteName} Ratio:`;
                const input = document.createElement('input');
                input.type = 'text';
                input.id = `root-ratio-input-${i}`;
                input.value = decimalToFractionString(rootNoteRatios[i], 128);
                input.style.width = '70px';
                group.appendChild(label);
                group.appendChild(input);
                container.appendChild(group);
            }

            const applyBtn = document.createElement('button');
            applyBtn.id = 'apply-custom-tuning-btn';
            applyBtn.textContent = 'Apply Tuning';
            applyBtn.classList.add('control-button');
            applyBtn.style.fontSize = "0.8em";
            applyBtn.style.padding = "5px 8px";
            applyBtn.addEventListener('click', () => {
                try {
                    const newCFreq = parseFloat(document.getElementById('root-c-freq-input').value);
                    if (isNaN(newCFreq) || newCFreq <= 0) {
                        alert('Invalid C frequency. Must be a positive number.');
                        return;
                    }
                    rootCFrequency = newCFreq;

                    const newRatios = [1.0];
                    for (let i = 1; i < NOTE_NAMES.length; i++) {
                        const ratioStr = document.getElementById(`root-ratio-input-${i}`).value;
                        const newRatio = parseRatio(ratioStr);
                        if (isNaN(newRatio) || newRatio <= 0) {
                            alert(`Invalid ratio for ${NOTE_NAMES[i]}. Must be a positive number or fraction.`);
                            return;
                        }
                        newRatios.push(newRatio);
                    }
                    masterRootNoteRatios = newRatios; 
                    rootNoteRatios = [...masterRootNoteRatios];

                    recalculateBaseFrequencies();
                    selectRootNote(currentRootNoteName); 
                    alert('Custom tuning applied!');
                } catch (error) {
                    alert('Error applying tuning: ' + error.message);
                }
            });
            
            // MODIFIED: Create and add the Dynamic Root button here
            const dynamicRootBtn = document.createElement('button');
            dynamicRootBtn.id = 'toggle-dynamic-root-btn';
            dynamicRootBtn.textContent = `Root: ${isRootDynamic ? 'Dynamic' : 'Static'}`;
            dynamicRootBtn.classList.add('control-button');
            dynamicRootBtn.style.fontSize = "0.8em";
            dynamicRootBtn.style.padding = "5px 8px";
            dynamicRootBtn.classList.toggle('active', isRootDynamic);
            dynamicRootBtn.addEventListener('click', () => {
                isRootDynamic = !isRootDynamic;
                dynamicRootBtn.textContent = `Root: ${isRootDynamic ? 'Dynamic' : 'Static'}`;
                dynamicRootBtn.classList.toggle('active', isRootDynamic);
                if (!isRootDynamic) {
                    // Reset to original master tuning when switching back to static
                    rootNoteRatios = [...masterRootNoteRatios];
                    recalculateBaseFrequencies();
                    updateRootTuningInputs();
                    selectRootNote(currentRootNoteName); 
                } else {
                    // When switching to dynamic, re-select the root to apply the new relative tuning
                    selectRootNote(currentRootNoteName);
                }
            });

            container.appendChild(applyBtn);
            container.appendChild(dynamicRootBtn); // Add it to the container
        }

        async function handleDocumentKeyDown(event) {
            const activeElement = document.activeElement;
            const isTypingInInput = activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'SELECT' || activeElement.isContentEditable);
            if (isTypingInInput) return; 
            const key = event.key.toLowerCase(); const rawKey = event.key; 
            if (ROOT_NOTE_KEY_MAP[rawKey]) { event.preventDefault(); selectRootNote(ROOT_NOTE_KEY_MAP[rawKey]); return; }
            const pianoKeyIndex = PIANO_KEY_COMPUTER_KEY_MAP.indexOf(key);
            if (pianoKeyIndex !== -1 && pianoKeyIndex < NUM_PIANO_KEYS && keysData[pianoKeyIndex]) { 
                event.preventDefault();
                if (!activeKeyboardNotes[pianoKeyIndex]) { 
                    activeKeyboardNotes[pianoKeyIndex] = true;
                    const targetKeyElement = document.querySelector(`.piano-key[data-key-index="${pianoKeyIndex}"]`);
                    if (targetKeyElement) { 
                        await initAudioContext(); 
                        const freqObject = getFrequencyForKey(pianoKeyIndex);
                        if (freqObject !== null) { 
                            playSound(freqObject, `keyboard_key_${pianoKeyIndex}`, 'key'); 
                            targetKeyElement.classList.add('keyboard-playing'); 
                        }
                    }
                }
            }
        }

        function handleDocumentKeyUp(event) {
            const key = event.key.toLowerCase(); const rawKey = event.key;
            const pianoKeyIndex = PIANO_KEY_COMPUTER_KEY_MAP.indexOf(key);
            if (pianoKeyIndex !== -1 && pianoKeyIndex < NUM_PIANO_KEYS && keysData[pianoKeyIndex]) { 
                event.preventDefault();
                if (activeKeyboardNotes[pianoKeyIndex]) { activeKeyboardNotes[pianoKeyIndex] = false; stopSound(`keyboard_key_${pianoKeyIndex}`);
                    const targetKeyElement = document.querySelector(`.piano-key[data-key-index="${pianoKeyIndex}"]`);
                    targetKeyElement?.classList.remove('keyboard-playing'); 
                }
            }
             if (ROOT_NOTE_KEY_MAP[rawKey]) { const targetButton = rootSelectorDiv.querySelector(`.root-button[data-note-name="${ROOT_NOTE_KEY_MAP[rawKey]}"]`);
                 targetButton?.classList.remove('keyboard-active'); }
        }

        function setKeyEditMode(newState) {
            isKeyEditMode = newState;
            const container = document.querySelector('.piano-container');
            const btn = document.getElementById('toggle-key-edit-btn');
            container.classList.toggle('key-edit-mode-on', isKeyEditMode); 
            container.classList.toggle('key-edit-mode-off', !isKeyEditMode);
            if (btn) btn.textContent = `Key Edit: ${isKeyEditMode ? 'On' : 'Off'}`;
            if (btn) btn.classList.toggle('active', isKeyEditMode);
            document.querySelectorAll('.key-wrapper').forEach(kw => {
                kw.draggable = isKeyEditMode;
            });
        }
        function toggleKeyEditMode() { setKeyEditMode(!isKeyEditMode); }

        function setFrequencyDisplay(newState) {
            isFrequencyDisplayed = newState;
            const btn = document.getElementById('toggle-frequency-display-btn');
            if (btn) {
                btn.textContent = `Display Freq: ${isFrequencyDisplayed ? 'On' : 'Off'}`;
                btn.classList.toggle('active', isFrequencyDisplayed);
            }
            updateKeyDisplays();
        }
        function toggleFrequencyDisplay() { setFrequencyDisplay(!isFrequencyDisplayed); }

        function setFullscreen(state) {
            const container = document.querySelector('.piano-container');
            const closeBtn = document.getElementById('close-fullscreen-btn');
            if (state) {
                container.classList.add('fullscreen-keys-active');
                closeBtn.style.display = 'block';
                if (isKeyEditMode) {
                    setKeyEditMode(false); 
                }
            } else {
                container.classList.remove('fullscreen-keys-active');
                closeBtn.style.display = 'none';
            }
        }

        function setRowStagger(newState) {
            areRowsStaggered = newState;
            const container = document.getElementById('piano-keys-container');
            const btn = document.getElementById('toggle-row-stagger-btn');
            container.classList.toggle('staggered-rows', areRowsStaggered);
            btn.textContent = `Stagger: ${areRowsStaggered ? 'On' : 'Off'}`;
            btn.classList.toggle('active', areRowsStaggered);
        }
        function toggleRowStagger() { setRowStagger(!areRowsStaggered); }

        function updatePitchShiftUI() {
            if (pitchShiftSlider) {
                pitchShiftSlider.value = globalPitchShiftSemitones;
            }
            if (pitchShiftDisplay) {
                pitchShiftDisplay.textContent = `${globalPitchShiftSemitones.toFixed(2)} st`;
            }
        }

        function setupExtraUIControls() {
            skinSelect = document.getElementById('skin-select');
            keyShapeSelect = document.getElementById('key-shape-select');
            edoInput = document.getElementById('edo-input');
            applyTuningBtn = document.getElementById('apply-edo-btn');

            document.getElementById('toggle-key-edit-btn')?.addEventListener('click', toggleKeyEditMode);
            document.getElementById('toggle-row-stagger-btn')?.addEventListener('click', toggleRowStagger);
            document.getElementById('mute-all-btn')?.addEventListener('click', muteAll);
            document.getElementById('toggle-frequency-display-btn')?.addEventListener('click', toggleFrequencyDisplay);
            document.getElementById('toggle-fullscreen-btn')?.addEventListener('click', () => setFullscreen(true));
            document.getElementById('close-fullscreen-btn')?.addEventListener('click', () => setFullscreen(false));

            if (skinSelect) skinSelect.addEventListener('change', (e) => applySkin(e.target.value));
            if (keyShapeSelect) keyShapeSelect.addEventListener('change', (e) => applyKeyShape(e.target.value));
            if (applyTuningBtn) applyTuningBtn.addEventListener('click', handleApplyEdoOrJi);
        }
        
        function applySkin(skinClassName) {
            document.body.className = skinClassName;
            currentSkin = skinClassName;
        }

        function applyKeyShape(shapeClassName) {
            const container = document.getElementById('piano-keys-container');
            if (container) {
                container.className = 'piano-keys-container'; 
                container.classList.add(shapeClassName);
                if (areRowsStaggered) container.classList.add('staggered-rows');
            }
            currentKeyShape = shapeClassName;
            applyZoom(zoomSlider.value); 
        }

        function handleApplyEdoOrJi() {
            if (isEdoModeActive) {
                // --- Apply JI Logic (revert root system) ---
                masterRootNoteRatios = [...JUST_INTONATION_RATIOS];

                rootNoteRatios = [...masterRootNoteRatios]; 
                if (isRootDynamic) {
                    const rootIndex = NOTE_NAMES.indexOf(currentRootNoteName);
                    if (rootIndex !== -1) {
                        const rootRatio = masterRootNoteRatios[rootIndex];
                        rootNoteRatios = masterRootNoteRatios.map(r => r / rootRatio);
                    }
                }
                
                recalculateBaseFrequencies();
                updateRootTuningInputs();
                selectRootNote(currentRootNoteName); 

                applyTuningBtn.textContent = 'Apply EDO';
                isEdoModeActive = false;
                alert('Just Intonation root system restored.');

            } else {
                // --- Apply EDO Logic ---
                const edoValue = parseInt(edoInput.value, 10);
                if (isNaN(edoValue) || edoValue < 1 || edoValue > 100) {
                    alert("Please enter a valid EDO value (1-100).");
                    return;
                }

                const newMasterRatios = [];
                for (let i = 0; i < 12; i++) {
                    newMasterRatios.push(Math.pow(2, i / edoValue));
                }
                masterRootNoteRatios = newMasterRatios;
                
                rootNoteRatios = [...masterRootNoteRatios]; 
                if (isRootDynamic) {
                    const rootIndex = NOTE_NAMES.indexOf(currentRootNoteName);
                    if (rootIndex !== -1) {
                        const rootRatio = masterRootNoteRatios[rootIndex];
                        rootNoteRatios = masterRootNoteRatios.map(r => r / rootRatio);
                    }
                }
                
                for (let i = 0; i < NUM_PIANO_KEYS; i++) {
                    if (keysData[i]) { 
                        const ratio = Math.pow(2, i / edoValue);
                        keysData[i].interval = decimalToFractionString(ratio);
                    }
                }

                recalculateBaseFrequencies();
                updateRootTuningInputs();
                selectRootNote(currentRootNoteName);

                applyTuningBtn.textContent = 'Apply JI';
                isEdoModeActive = true;
                alert(`${edoValue}-EDO tuning applied to the root note system and all key slots!`);
            }
        }


        document.addEventListener('DOMContentLoaded', async () => {
            octaveUpBtn = document.getElementById('octave-up-btn'); 
            octaveDownBtn = document.getElementById('octave-down-btn');
            octaveDisplaySpan = document.getElementById('octave-display'); 
            numPianoKeysInput = document.getElementById('num-piano-keys-input');
            applyPianoKeysBtn = document.getElementById('apply-piano-keys-btn');
            maxKeysPerRowInput = document.getElementById('max-keys-per-row-input');
            applyMaxKeysRowBtn = document.getElementById('apply-max-keys-row-btn');
            pitchShiftSlider = document.getElementById('pitch-shift-slider');
            pitchShiftDisplay = document.getElementById('pitch-shift-display');

            try {
                if (typeof getSoundDefinitionFunctionBody !== 'function') {
                    throw new Error("sound-definitions.js did not load correctly.");
                }
                soundDefinitionFunctionBody = getSoundDefinitionFunctionBody();
            } catch (e) {
                console.error("Could not load sound definitions. Using a fallback.", e);
                alert("Error: sound-definitions.js could not be loaded or is invalid. A fallback sine wave will be used.");
                soundDefinitionFunctionBody = `
                    switch (soundType) {
                        case 'sine': default:
                            mainGain = audioContext.createGain(); mainOsc = audioContext.createOscillator();
                            mainOsc.type = 'sine'; mainOsc.connect(mainGain);
                            mainGain.gain.setValueAtTime(0, now); mainGain.gain.linearRampToValueAtTime(0.3, now + 0.02); 
                            mainOsc.frequency.setValueAtTime(frequency, now); mainOsc.start(now); break;
                    }
                    return { mainOsc, mainGain, isSelfStopping: false, soundNaturalDuration: 0.1 };
                `;
            }

            currentSoundGenerator = new Function(
                'soundType', 'frequency', 'now', 'audioContext', 'masterGainNode', 'soundId', 'activeOscillators',
                soundDefinitionFunctionBody
            );

            setupExtraUIControls();
            await initAudioContext(); 
            setupGlobalAudioControls(); 
            setupMIDI();
            recalculateBaseFrequencies();
            generateRootTuningControls();
            
            if(numPianoKeysInput) numPianoKeysInput.value = NUM_PIANO_KEYS;
            if(maxKeysPerRowInput) maxKeysPerRowInput.value = currentMaxKeysPerRow;
            
            resizeKeyDataArray(); 
            const firstValidKeyIndex = keysData.findIndex(k => k !== null);
            SEQ_ROW_KEY_INDICES = Array(NUM_SEQ_MELODIC_ROWS).fill(firstValidKeyIndex !== -1 ? firstValidKeyIndex : 0);

            if(applyPianoKeysBtn) applyPianoKeysBtn.addEventListener('click', handleApplyPianoKeys);
            if(applyMaxKeysRowBtn) applyMaxKeysRowBtn.addEventListener('click', handleApplyMaxKeysPerRow);

            createPianoKeysAndRootSelector();
            setKeyEditMode(isKeyEditMode);

            setupChordControls(); 
            createSequencerGrid(); 
            setupSequencerControls(); 
            
            updateOctaveDisplay(); 
            if(zoomSlider) {
                zoomSlider.addEventListener('input', (event) => applyZoom(event.target.value));
                applyZoom(zoomSlider.value);
            }
            if(pitchShiftSlider) {
                 pitchShiftSlider.addEventListener('input', (e) => {
                    globalPitchShiftSemitones = parseFloat(e.target.value);
                    updatePitchShiftUI();
                    updateAllActiveNotePitches();
                });
            }
            octaveUpBtn?.addEventListener('click', async () => { await initAudioContext(); if (currentOctaveOffset < MAX_OCTAVE_OFFSET) { currentOctaveOffset++; updateOctaveDisplay(); }});
            octaveDownBtn?.addEventListener('click', async () => { await initAudioContext(); if (currentOctaveOffset > MIN_OCTAVE_OFFSET) { currentOctaveOffset--; updateOctaveDisplay(); }});
            
            document.addEventListener('keydown', handleDocumentKeyDown); 
            document.addEventListener('keyup', handleDocumentKeyUp);
            
            const startAudioOnFirstInteraction = async () => { 
                await initAudioContext(); 
                document.body.removeEventListener('click', startAudioOnFirstInteraction); 
                document.body.removeEventListener('touchstart', startAudioOnFirstInteraction); 
            };
            document.body.addEventListener('click', startAudioOnFirstInteraction, { once: true }); 
            document.body.addEventListener('touchstart', startAudioOnFirstInteraction, { once: true });
        });
    </script>
</body>
</html>

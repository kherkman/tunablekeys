
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tunable Keyboard, Sequencer & Drums</title>
    <style>
        :root {
            --bg-main: #2c3e50;
            --bg-container: #34495e;
            --bg-control-row: #293a4c;
            --bg-control-row-alt: #2c3e50;
            --bg-input: #566573;
            --bg-key-natural: linear-gradient(to bottom, #bdc3c7, #95a5a6);
            --bg-key-natural-hover: linear-gradient(to bottom, #dde1e2, #a8b6b7);
            --bg-key-sharp: linear-gradient(to bottom, #828c91, #6c7a89);
            --bg-key-sharp-hover: linear-gradient(to bottom, #95a0a6, #7f8c8d);
            --bg-key-playing: linear-gradient(to bottom, #f39c12, #e67e22);
            --bg-key-sharp-playing: linear-gradient(to bottom, #d35400, #c0392b);
            --bg-chord-playing: linear-gradient(to bottom, #2ecc71, #27ae60);
            --bg-chord-sharp-playing: linear-gradient(to bottom, #16a085, #138d75);
            --color-text-main: #ecf0f1;
            --color-text-muted: #bdc3c7;
            --color-text-key-natural: #2c3e50;
            --color-text-key-sharp: #ecf0f1;
            --color-accent-primary: #e67e22;
            --color-accent-secondary: #1abc9c;
            --color-accent-tertiary: #8e44ad;
            --border-color-light: #4a6278;
            --border-color-dark: #7f8c8d;
        }

        .skin-vintage-cream {
            --bg-main: #e8dcb5;
            --bg-container: #d3c3a0;
            --bg-control-row: #c1b391;
            --bg-control-row-alt: #e8dcb5;
            --bg-input: #f3ead3;
            --bg-key-natural: linear-gradient(to bottom, #f5f5dc, #e0e0c8);
            --bg-key-natural-hover: linear-gradient(to bottom, #ffffff, #f0f0e0);
            --bg-key-sharp: linear-gradient(to bottom, #8b4513, #6a340f);
            --bg-key-sharp-hover: linear-gradient(to bottom, #a0522d, #8b4513);
            --bg-key-playing: linear-gradient(to bottom, #c7a500, #b39300);
            --bg-key-sharp-playing: linear-gradient(to bottom, #e74c3c, #c0392b);
            --bg-chord-playing: linear-gradient(to bottom, #5d9e5d, #4c8a4c);
            --bg-chord-sharp-playing: linear-gradient(to bottom, #4682b4, #3672a4);
            --color-text-main: #4a3c31;
            --color-text-muted: #6b5a4b;
            --color-text-key-natural: #4a3c31;
            --color-text-key-sharp: #f5f5dc;
            --color-accent-primary: #b39300;
            --color-accent-secondary: #4c8a4c;
            --color-accent-tertiary: #800000;
            --border-color-light: #ab9b7c;
            --border-color-dark: #8b7b6b;
        }

        .skin-neon-wave {
            --bg-main: #0d0221;
            --bg-container: #1a0a38;
            --bg-control-row: #2a0e50;
            --bg-control-row-alt: #0d0221;
            --bg-input: #3c1f70;
            --bg-key-natural: linear-gradient(to bottom, #4a1e9e, #2a0e50);
            --bg-key-natural-hover: linear-gradient(to bottom, #6a3ecf, #4a1e9e);
            --bg-key-sharp: linear-gradient(to bottom, #300f6b, #150530);
            --bg-key-sharp-hover: linear-gradient(to bottom, #4a1e9e, #300f6b);
            --bg-key-playing: linear-gradient(to bottom, #ff00ff, #e600e6);
            --bg-key-sharp-playing: linear-gradient(to bottom, #00ffff, #00e6e6);
            --bg-chord-playing: linear-gradient(to bottom, #00ff00, #00e600);
            --bg-chord-sharp-playing: linear-gradient(to bottom, #ffff00, #e6e600);
            --color-text-main: #00ffcc;
            --color-text-muted: #00ccff;
            --color-text-key-natural: #ffffff;
            --color-text-key-sharp: #ffffff;
            --color-accent-primary: #ff00ff;
            --color-accent-secondary: #00ffff;
            --color-accent-tertiary: #ffff00;
            --border-color-light: #5a3eaf;
            --border-color-dark: #7a5ecf;
        }

        .skin-minimalist-light {
            --bg-main: #f0f2f5;
            --bg-container: #ffffff;
            --bg-control-row: #e4e6eb;
            --bg-control-row-alt: #f0f2f5;
            --bg-input: #e4e6eb;
            --bg-key-natural: linear-gradient(to bottom, #ffffff, #e4e6eb);
            --bg-key-natural-hover: linear-gradient(to bottom, #ffffff, #f0f2f5);
            --bg-key-sharp: linear-gradient(to bottom, #333333, #1a1a1a);
            --bg-key-sharp-hover: linear-gradient(to bottom, #4d4d4d, #333333);
            --bg-key-playing: linear-gradient(to bottom, #007bff, #0056b3);
            --bg-key-sharp-playing: linear-gradient(to bottom, #dc3545, #b02a37);
            --bg-chord-playing: linear-gradient(to bottom, #28a745, #1e7e34);
            --bg-chord-sharp-playing: linear-gradient(to bottom, #17a2b8, #117a8b);
            --color-text-main: #050505;
            --color-text-muted: #65676b;
            --color-text-key-natural: #050505;
            --color-text-key-sharp: #ffffff;
            --color-accent-primary: #007bff;
            --color-accent-secondary: #28a745;
            --color-accent-tertiary: #6f42c1;
            --border-color-light: #ced0d4;
            --border-color-dark: #bec3c9;
        }

        .skin-forest-grove {
            --bg-main: #2d3a2c;
            --bg-container: #4a5d4a;
            --bg-control-row: #3e4d3d;
            --bg-control-row-alt: #2d3a2c;
            --bg-input: #6a7d6a;
            --bg-key-natural: linear-gradient(to bottom, #e0d8c0, #c8c0a8);
            --bg-key-natural-hover: linear-gradient(to bottom, #f0ead8, #d8d0b8);
            --bg-key-sharp: linear-gradient(to bottom, #5c3d2e, #4a2d1e);
            --bg-key-sharp-hover: linear-gradient(to bottom, #6c4d3e, #5c3d2e);
            --bg-key-playing: linear-gradient(to bottom, #76b852, #63a042);
            --bg-key-sharp-playing: linear-gradient(to bottom, #d35400, #b04400);
            --bg-chord-playing: linear-gradient(to bottom, #d35400, #b04400);
            --bg-chord-sharp-playing: linear-gradient(to bottom, #8c4c1e, #7a3a0e);
            --color-text-main: #f0f0e0;
            --color-text-muted: #b8b098;
            --color-text-key-natural: #2d3a2c;
            --color-text-key-sharp: #f0f0e0;
            --color-accent-primary: #76b852;
            --color-accent-secondary: #d35400;
            --color-accent-tertiary: #8b5a2b;
            --border-color-light: #6a7d6a;
            --border-color-dark: #8b7b6b;
        }

        .skin-oceanic-deep {
            --bg-main: #0c1445;
            --bg-container: #142163;
            --bg-control-row: #0f1a58;
            --bg-control-row-alt: #0c1445;
            --bg-input: #233173;
            --bg-key-natural: linear-gradient(to bottom, #a7d2cb, #89b0a9);
            --bg-key-natural-hover: linear-gradient(to bottom, #b7e2db, #99c0b9);
            --bg-key-sharp: linear-gradient(to bottom, #006a71, #005a61);
            --bg-key-sharp-hover: linear-gradient(to bottom, #008a91, #006a71);
            --bg-key-playing: linear-gradient(to bottom, #ff6b6b, #ee5a5a);
            --bg-key-sharp-playing: linear-gradient(to bottom, #f9d423, #e6c110);
            --bg-chord-playing: linear-gradient(to bottom, #48cae4, #35b8d2);
            --bg-chord-sharp-playing: linear-gradient(to bottom, #0096c7, #0084b5);
            --color-text-main: #e0ffff;
            --color-text-muted: #add8e6;
            --color-text-key-natural: #0c1445;
            --color-text-key-sharp: #e0ffff;
            --color-accent-primary: #ff6b6b;
            --color-accent-secondary: #f9d423;
            --color-accent-tertiary: #48cae4;
            --border-color-light: #233173;
            --border-color-dark: #455193;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-main);
            color: var(--color-text-main);
            display: flex;
            justify-content: center;
            align-items: flex-start; 
            min-height: 100vh;
            margin: 0;
            padding: 15px;
            box-sizing: border-box;
            overflow-x: hidden;
            transition: background-color 0.3s, color 0.3s;
        }

        .piano-container {
            display: flex;
            flex-direction: column; 
            align-items: center; 
            background-color: var(--bg-container);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            gap: 15px;
            max-width: 98vw;
            transition: background-color 0.3s;
        }
        
        .main-instrument-area {
            display: flex;
            width: 100%;
            gap: 15px;
        }

        .root-selector {
            display: flex;
            flex-direction: column;
            gap: 7px;
            align-items: center;
            padding-right: 12px;
            border-right: 1px solid var(--border-color-light);
            flex-shrink: 0;
        }

        .root-button {
            background-color: var(--color-accent-tertiary);
            color: white;
            border: none;
            padding: 9px 14px;
            font-size: 0.9em;
            font-weight: bold;
            cursor: pointer;
            border-radius: 7px;
            transition: background-color 0.2s, transform 0.1s;
            width: 50px;
            text-align: center;
            box-shadow: 0 3px 8px rgba(0,0,0,0.2);
        }

        .root-button:hover { filter: brightness(1.1); }
        .root-button.active, .root-button.keyboard-active { 
            background-color: var(--color-accent-primary);
            transform: scale(1.05);
            box-shadow: 0 5px 15px color-mix(in srgb, var(--color-accent-primary) 40%, transparent);
        }

        .keys-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex-grow: 1;
            min-width: 0;
        }
        
        .piano-title {
            font-size: 1.5em;
            margin-bottom: 12px;
            color: var(--color-accent-primary);
            text-align: center;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }
        .instrument-config-row { 
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            align-items: center;
            width: 100%;
            margin-bottom: 8px;
            padding: 6px;
            background-color: var(--bg-control-row); 
            border-radius: 6px;
        }
        .key-setup-io { 
             display: flex;
             gap: 8px;
             margin-top: 5px; 
        }

        .global-controls-row { 
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px; 
            align-items: center;
            width: 100%;
            margin-bottom: 10px;
            padding: 8px;
            background-color: var(--bg-control-row-alt);
            border-radius: 6px;
        }
        .control-group {
            display: flex;
            align-items: center;
            gap: 6px; 
        }
        .control-group label { font-size: 0.8em; color: var(--color-text-muted); white-space: nowrap;}
        .control-group select, .control-group input[type="range"], .control-group input[type="number"], .control-group input[type="text"] {
            background-color: var(--bg-input);
            color: var(--color-text-main);
            border: 1px solid var(--border-color-light);
            border-radius: 4px;
            padding: 4px 6px;
            font-size: 0.75em; 
        }
         .control-group input[type="range"] { padding: 0;} 
         .control-group input[type="number"] { width: 45px; }
         .control-group select { max-width: 120px; }

        .controls-waveform-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            margin-bottom: 12px;
            gap: 12px;
        }

        .top-controls-row {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
            align-items: center;
            width: 100%;
        }

        .octave-controls, .zoom-controls, .pitch-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px 10px;
            background-color: var(--bg-control-row-alt);
            border-radius: 6px;
        }
        .pitch-controls label { font-size: 0.85em; color: var(--color-text-muted); }
        #pitch-shift-slider { width: 100px; cursor: pointer; }
        #pitch-shift-display { font-size: 0.85em; color: var(--color-text-muted); min-width: 60px; text-align: center; }

        .control-button { 
            background-color: var(--bg-input); 
            color: var(--color-text-main);
            border: none;
            padding: 7px 10px;
            font-size: 0.85em;
            font-weight: bold;
            cursor: pointer;
            border-radius: 5px;
            transition: background-color 0.2s, transform 0.1s;
        }
        .control-button:hover { filter: brightness(1.15); }
        .control-button:active { transform: scale(0.95); }
        .control-button:disabled {
            background-color: #414e5a;
            color: #7f8c8d;
            cursor: not-allowed;
        }
        .control-button.active {
            background-color: var(--color-accent-primary);
        }

        #octave-display {
            font-size: 0.85em;
            color: var(--color-text-muted);
            min-width: 55px;
            text-align: center;
            font-weight: bold;
        }

        .zoom-controls label { font-size: 0.85em; color: var(--color-text-muted); }
        #zoom-slider { width: 130px; cursor: pointer; }
        input[type=range] { -webkit-appearance: none; appearance: none; background: transparent; }
        input[type=range]::-webkit-slider-runnable-track { height: 7px; background: var(--bg-input); border-radius: 3.5px; }
        input[type=range]::-moz-range-track { height: 7px; background: var(--bg-input); border-radius: 3.5px; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; margin-top: -4.5px;
            background-color: var(--color-accent-primary); height: 16px; width: 16px; border-radius: 50%;
            border: 2px solid var(--color-text-main);
        }
        input[type=range]::-moz-range-thumb {
            background-color: var(--color-accent-primary); height: 12px; width: 12px; border-radius: 50%;
            border: 2px solid var(--color-text-main);
        }

        #waveform-canvas {
            width: 100%;
            max-width: 500px;
            height: 70px;
            background-color: #22303f;
            border-radius: 5px;
            border: 1px solid var(--border-color-light);
            box-shadow: inset 0 0 8px rgba(0,0,0,0.2);
        }
        
        #interval-display-line-container {
            width: 100%;
            max-width: 500px;
            height: 40px;
            background-color: #22303f;
            border-radius: 5px;
            border: 1px solid var(--border-color-light);
            padding: 0 15px;
            box-sizing: border-box;
            position: relative;
            display: flex;
            align-items: center;
            margin-top: -5px;
            margin-bottom: 12px;
        }

        #interval-display-line {
            width: 100%;
            height: 2px;
            background-color: var(--border-color-light);
            position: relative;
        }

        .interval-marker {
            position: absolute;
            bottom: -2px;
            width: 2px;
            height: 6px;
            background-color: var(--color-accent-secondary);
            transform: translateX(-50%);
        }

        .interval-marker-label {
            position: absolute;
            bottom: 8px;
            transform: translateX(-50%);
            font-size: 0.6em;
            color: var(--color-text-muted);
            white-space: nowrap;
            background: color-mix(in srgb, var(--bg-main) 70%, transparent);
            padding: 1px 3px;
            border-radius: 2px;
        }

        .keys-scroller { width: 100%; overflow-x: auto; padding-bottom: 8px; }
        .piano-keys-container { display: flex; flex-direction: column; gap: 8px; min-height: 150px; }
        .piano-keys-row { display: flex; flex-wrap: nowrap; gap: 8px; justify-content: flex-start; transition: margin-left 0.3s ease-in-out; }
        
        .staggered-rows .piano-keys-row:nth-child(even) {
             margin-left: calc((var(--key-width, 65px) + 8px) / 2);
        }

        .key-wrapper, .key-placeholder { 
            position: relative; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            gap: 5px; 
            flex-shrink: 0;
        }

        .key-placeholder {
            width: var(--key-width, 65px);
            height: 145px;
            border: 2px dashed var(--border-color-light);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--border-color-light);
            font-size: 2em;
            font-weight: bold;
            user-select: none;
            box-sizing: border-box;
            transition: background-color 0.2s, border-color 0.2s;
            cursor: pointer;
        }
        .key-placeholder:hover {
            border-color: var(--color-accent-secondary);
            color: var(--color-accent-secondary);
        }
        .key-placeholder.drag-over {
            background-color: color-mix(in srgb, var(--color-accent-primary) 20%, transparent);
            border-color: var(--color-accent-primary);
        }

        .interval-input {
            padding: 5px; font-size: 0.75em; text-align: center; border: 1px solid var(--border-color-dark);
            background-color: var(--bg-input); color: var(--color-text-main);
            border-radius: 4px; box-shadow: inset 0 1px 2px rgba(0,0,0,0.1); flex-shrink: 0;
        }
        .interval-input:focus {
            outline: none; border-color: var(--color-accent-primary);
            box-shadow: 0 0 4px color-mix(in srgb, var(--color-accent-primary) 50%, transparent);
        }
        .piano-key {
            height: 110px; background: var(--bg-key-natural);
            border: 1.5px solid var(--border-color-dark); border-bottom: 4px solid var(--border-color-dark);
            border-radius: 7px; cursor: pointer; display: flex;
            flex-direction: column; justify-content: flex-end; align-items: center;
            padding-bottom: 8px; font-weight: bold; color: var(--color-text-key-natural);
            transition: all 0.1s;
            box-shadow: 0 3px 6px rgba(0,0,0,0.2); user-select: none; flex-shrink: 0;
        }
        .piano-key:hover { background: var(--bg-key-natural-hover); }
        .piano-key.playing, .piano-key.keyboard-playing { 
            background: var(--bg-key-playing); color: white;
            transform: translateY(1.5px); border-bottom-width: 2.5px;
            box-shadow: 0 1.5px 4px rgba(0,0,0,0.3);
        }
        .note-name { font-size: 0.9em; margin-bottom: 3px; }
        .interval-display { font-size: 0.65em; color: var(--color-text-key-natural); }
        .piano-key.playing .interval-display, .piano-key.keyboard-playing .interval-display { color: #f0f0f0; }

        .piano-key.sharp-flat-key { background: var(--bg-key-sharp); color: var(--color-text-key-sharp); }
        .piano-key.sharp-flat-key:hover { background: var(--bg-key-sharp-hover); }
        .piano-key.sharp-flat-key.playing, .piano-key.sharp-flat-key.keyboard-playing { background: var(--bg-key-sharp-playing); color: white; }
        .piano-key.sharp-flat-key .interval-display { color: var(--color-text-muted); }
        .piano-key.sharp-flat-key.playing .interval-display, .piano-key.sharp-flat-key.keyboard-playing .interval-display { color: #f0f0f0; }

        .piano-key.chord-playing { background: var(--bg-chord-playing); color: white; }
        .piano-key.sharp-flat-key.chord-playing { background: var(--bg-chord-sharp-playing); }
        .piano-key.chord-playing .interval-display { color: #f0f0f0; }

        .shape-square .piano-key { height: var(--key-width, 65px); width: var(--key-width, 65px) !important; justify-content: center; }
        .shape-circle .piano-key { height: var(--key-width, 65px); width: var(--key-width, 65px) !important; border-radius: 50%; justify-content: center; }
        .shape-hexagon .piano-key { 
            height: calc(var(--key-width, 65px) * 1.1547); width: var(--key-width, 65px) !important;
            background: var(--bg-key-natural); border: none;
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            justify-content: center;
        }
        .shape-hexagon .piano-key.sharp-flat-key { background: var(--bg-key-sharp); }
        .shape-hexagon .piano-key.playing, .shape-hexagon .piano-key.keyboard-playing { background: var(--bg-key-playing); }
        .shape-hexagon .piano-key.sharp-flat-key.playing, .shape-hexagon .piano-key.sharp-flat-key.keyboard-playing { background: var(--bg-key-sharp-playing); }
        .shape-hexagon .piano-key.chord-playing { background: var(--bg-chord-playing); }

        .delete-key-btn {
            position: absolute; top: -8px; right: -5px; width: 18px; height: 18px;
            background: #e74c3c; color: white; border: 1px solid white;
            border-radius: 50%; cursor: pointer; font-size: 12px;
            font-weight: bold; line-height: 16px; text-align: center;
            opacity: 0.5; transition: opacity 0.2s, transform 0.2s;
            z-index: 10;
        }
        .key-wrapper:hover .delete-key-btn { opacity: 1; }
        .delete-key-btn:hover { transform: scale(1.1); }
        
        .key-wrapper.dragging { opacity: 0.4; }
        .key-wrapper.drag-over, .key-placeholder.drag-over { border: 2px dashed var(--color-accent-primary); border-radius: 8px; }
        
        .key-edit-mode-off .interval-input,
        .key-edit-mode-off .delete-key-btn {
            display: none;
        }
        .key-edit-mode-off .key-wrapper {
            cursor: default;
        }
        .key-edit-mode-off .piano-key {
            cursor: pointer;
        }
        .key-edit-mode-off .key-placeholder {
            display: none;
        }

        .collapsible-section {
            width: 100%;
        }
        details > summary {
            list-style: none;
        }
        details > summary::-webkit-details-marker {
            display: none;
        }
        .collapsible-section-summary {
            cursor: pointer;
            font-weight: bold;
            font-size: 1.3em;
            color: var(--color-accent-secondary);
            padding: 8px 12px;
            background-color: var(--bg-control-row);
            border-radius: 6px;
            margin-bottom: 10px;
            transition: background-color 0.2s;
        }
        .collapsible-section-summary:hover {
            filter: brightness(1.1);
        }

        .chord-config-row {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
            padding: 8px;
            background-color: var(--bg-control-row);
            border-radius: 6px;
        }

        .chord-controls-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px; 
            padding: 10px;
            background-color: var(--bg-control-row-alt);
            border-radius: 8px;
            width: 100%;
            max-width: 700px;
        }
        .chord-buttons-row {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px; 
            width: 100%;
        }
        .chord-definition-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            padding: 10px;
            background-color: var(--bg-container);
            border-radius: 6px;
            flex: 1 1 150px; 
            max-width: 200px; 
            box-sizing: border-box;
        }
        .chord-num-notes-control {
             display: flex;
             align-items: center;
             gap: 5px;
             margin-bottom: 5px;
        }
        .chord-num-notes-control label {
            font-size: 0.75em;
        }
        .chord-num-notes-control input[type="number"] {
            width: 35px; 
            font-size: 0.7em;
            padding: 3px 4px;
        }
        .chord-key-selectors {
            display: flex;
            flex-direction: column;
            gap: 5px;
            align-items: flex-start;
            width: 100%; 
        }
        .chord-key-selectors .control-group {
            gap: 4px;
            width: 100%; 
            justify-content: space-between; 
        }
        .chord-key-selectors label {
            font-size: 0.7em;
            min-width: 40px;
        }
        .chord-key-selectors select {
            font-size: 0.7em;
            padding: 3px 4px;
            flex-grow: 1; 
        }

        .chord-button {
            background-color: var(--color-accent-secondary); 
            color: white;
            border: none;
            padding: 8px 12px;
            font-size: 0.8em;
            font-weight: bold;
            cursor: pointer;
            border-radius: 5px;
            transition: background-color 0.2s, transform 0.1s;
            min-width: 80px;
            margin-bottom: 5px; 
        }
        .chord-button:hover { filter: brightness(0.9); }
        .chord-button.playing { background-color: var(--color-accent-primary); transform: scale(1.03);}

        .sequencer-section {
            padding: 15px;
            background-color: var(--bg-control-row-alt); 
            border-radius: 10px;
            width: 100%;
            max-width: 850px; 
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        .sequencer-title {
            font-size: 1.3em;
            color: var(--color-accent-secondary); 
            text-align: center;
            margin-bottom: 15px;
        }
        .sequencer-main-controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-around; 
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            padding: 8px;
            background-color: var(--bg-container);
            border-radius: 6px;
        }
        .sequencer-main-controls label { font-size: 0.85em; white-space: nowrap;}
        .sequencer-main-controls input[type="number"] {
            width: 50px; 
            padding: 5px;
            font-size: 0.85em;
            background-color: var(--bg-input);
            color: var(--color-text-main);
            border: 1px solid var(--border-color-dark);
            border-radius: 4px;
        }
        #seq-tempo-slider { width: 120px; }
        #seq-tempo-display { font-size: 0.85em; min-width: 60px; text-align: center; }

        .sequencer-grid-container {
            display: flex;
            flex-direction: column;
            gap: 5px;
            overflow-x: auto; 
            padding: 5px;
            background: color-mix(in srgb, var(--bg-main) 80%, black);
            border-radius: 5px;
        }
        .sequencer-row-wrapper { 
            display: grid; 
            grid-template-columns: 100px auto; 
            gap: 8px; 
            align-items: center;
            margin-bottom: 3px; 
        }
        .seq-drum-control-cell {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            justify-content: center;
            gap: 3px;
            box-sizing: border-box;
        }
        .seq-row-label { 
            font-size: 0.7em;
            padding: 3px 6px;
            background-color: var(--bg-input);
            color: var(--color-text-main);
            border: 1px solid var(--border-color-light);
            border-radius: 3px;
            text-align: center;
            font-weight: bold;
            box-sizing: border-box;
            cursor: pointer;
        }
        .seq-row-key-select {
            font-size: 0.7em;
            padding: 3px; 
            background-color: var(--bg-input);
            color: var(--color-text-main);
            border: 1px solid var(--border-color-light);
            border-radius: 3px;
            width: 100%; 
            box-sizing: border-box;
        }

        .sequencer-row { 
            display: flex;
            gap: 4px; 
        }
        .sequencer-step {
            width: 26px; 
            height: 26px;
            background-color: var(--border-color-light); 
            border: 1px solid var(--bg-input);
            border-radius: 4px;
            cursor: pointer;
            transition: background-color: 0.1s;
            flex-shrink: 0; 
        }
        .sequencer-step:hover { background-color: color-mix(in srgb, var(--border-color-light) 80%, white); }
        .sequencer-step.active { background-color: var(--color-accent-secondary); }
        .sequencer-step.drum-kick.active { background-color: #e74c3c; } 
        .sequencer-step.drum-snare.active { background-color: #3498db; } 
        .sequencer-step.drum-hi-hat.active { background-color: #f1c40f; } 
        .sequencer-step.current {
             box-shadow: 0 0 0 2px var(--color-accent-primary) inset; 
        }
        .sequencer-file-ops {
            margin-top: 15px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }

        @media (max-width: 1000px) {
            .main-instrument-area { flex-direction: column; align-items: center; }
            .root-selector {
                flex-direction: row; flex-wrap: wrap; justify-content: center;
                margin-bottom: 15px; padding-right: 0; border-right: none;
                border-bottom: 1px solid var(--border-color-light); padding-bottom: 12px;
            }
            .keys-area { width: 100%; }
            .global-controls-row, .instrument-config-row {flex-direction: column;}
        }
        @media (max-width: 768px) {
            body { padding: 10px;}
            .piano-key { height: 90px; }
            .piano-keys-container { min-height: 110px; } 
            #zoom-slider { width: 110px; }
            .piano-title { font-size: 1.3em; }
            .top-controls-row { gap: 10px; }
            .octave-controls, .zoom-controls, .pitch-controls, .control-group { padding: 4px 8px;}
            .control-button, #octave-display, .zoom-controls label, .pitch-controls label, #pitch-shift-display, .control-group label { font-size: 0.8em; }

            .sequencer-step { width: 22px; height: 22px; }
            .sequencer-main-controls { flex-direction: column; gap: 12px; }
            .sequencer-row-wrapper { grid-template-columns: 85px auto; } 
            .seq-row-label, .seq-row-key-select { font-size: 0.65em;}
        }
        @media (max-width: 480px) {
            .root-button { padding: 7px 10px; width: 45px; font-size: 0.8em;}
            .piano-key { height: 80px; }
            .note-name { font-size: 0.8em; }
            .interval-display { font-size: 0.6em; }
            .piano-keys-container { min-height: 100px; }
            .sequencer-step { width: 20px; height: 20px; }
            .sequencer-row-wrapper { grid-template-columns: 75px auto; } 
            .seq-row-label, .seq-row-key-select { font-size: 0.6em;}
            .global-controls-row .control-group, .instrument-config-row .control-group {width: 90%; justify-content: space-between;}
            .global-controls-row .control-group select, 
            .global-controls-row .control-group input[type="range"] { flex-grow: 1;}
            .chord-key-selectors {align-items: center;}
            .chord-key-selectors .control-group {width: 100%; justify-content: space-between;}
            .chord-definition-group { flex-basis: 120px; max-width: 180px;}
        }

    </style>
</head>
<body class="skin-dark-space">

    <div class="piano-container">
        <div class="main-instrument-area">
            <div class="root-selector">
                <!-- Root note buttons will be generated here -->
            </div>
            <div class="keys-area">
                <div class="piano-title">Microtonal Keyboard & Sequencer</div>

                <details class="collapsible-section" style="margin-top: 0;">
                    <summary class="collapsible-section-summary" style="font-size: 1.1em;">Custom Root Note Tuning</summary>
                    <div id="root-tuning-controls" style="display: flex; flex-wrap: wrap; gap: 10px; padding: 10px; justify-content: center; background-color: var(--bg-control-row); border-radius: 6px;">
                        <!-- Inputs will be generated here by JS -->
                    </div>
                </details>

                <div class="instrument-config-row">
                     <div class="control-group">
                        <label for="num-piano-keys-input">Number of Slots:</label>
                        <input type="number" id="num-piano-keys-input" value="13" min="1" max="61">
                        <button id="apply-piano-keys-btn" class="control-button" style="font-size:0.8em; padding: 5px 8px;">Apply Slots</button>
                    </div>
                    <div class="control-group">
                        <label for="max-keys-per-row-input">Max Keys/Row:</label>
                        <input type="number" id="max-keys-per-row-input" value="13" min="1" max="25">
                        <button id="apply-max-keys-row-btn" class="control-button" style="font-size:0.8em; padding: 5px 8px;">Apply Layout</button>
                    </div>
                    <div class="control-group">
                        <label for="edo-input">EDO:</label>
                        <input type="number" id="edo-input" value="12" min="1" max="100">
                        <button id="apply-edo-btn" class="control-button" style="font-size:0.8em; padding: 5px 8px;">Apply EDO</button>
                    </div>
                     <div class="control-group">
                        <button id="toggle-key-edit-btn" class="control-button active" style="font-size:0.8em; padding: 5px 8px;">Key Edit: On</button>
                        <button id="toggle-row-stagger-btn" class="control-button" style="font-size:0.8em; padding: 5px 8px;">Stagger: Off</button>
                        <button id="toggle-dynamic-root-btn" class="control-button" style="font-size:0.8em; padding: 5px 8px;">Root: Static</button>
                    </div>
                </div>

                <div class="global-controls-row">
                     <div class="control-group">
                        <label for="skin-select">Skin:</label>
                        <select id="skin-select">
                            <option value="skin-dark-space">Dark Space</option>
                            <option value="skin-vintage-cream">Vintage Cream</option>
                            <option value="skin-neon-wave">Neon Wave</option>
                            <option value="skin-minimalist-light">Minimalist Light</option>
                            <option value="skin-forest-grove">Forest Grove</option>
                            <option value="skin-oceanic-deep">Oceanic Deep</option>
                        </select>
                    </div>
                     <div class="control-group">
                        <label for="key-shape-select">Key Shape:</label>
                        <select id="key-shape-select">
                            <option value="shape-rectangle">Rectangle</option>
                            <option value="shape-square">Square</option>
                            <option value="shape-circle">Circle</option>
                            <option value="shape-hexagon">Hexagon</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label for="keys-volume-slider">Keys Vol:</label>
                        <input type="range" id="keys-volume-slider" min="0" max="1" value="0.7" step="0.01">
                    </div>
                     <div class="control-group">
                        <label for="sound-type-keys-select">Keys Sound:</label>
                        <select id="sound-type-keys-select">
                            <!-- Options will be populated by JavaScript -->
                        </select>
                    </div>
                    <div class="control-group">
                        <label for="sequencer-volume-slider">Seq Vol:</label>
                        <input type="range" id="sequencer-volume-slider" min="0" max="1" value="0.7" step="0.01">
                    </div>
                     <div class="control-group">
                        <label for="sound-type-seq-select">Seq Sound (Melodic):</label>
                         <select id="sound-type-seq-select">
                            <!-- Options will be populated by JavaScript -->
                        </select>
                    </div>
                <!-- <div class="control-group">
                        <button id="export-sound-definitions-btn" class="control-button" style="font-size:0.8em; padding: 5px 8px;">Export Sound Code</button>
                        <input type="file" id="import-sound-definitions-input" accept=".js,.txt" style="display: none;">
                        <button id="import-sound-definitions-btn" class="control-button" style="font-size:0.8em; padding: 5px 8px;">Import Sound Code</button>  
                    </div>   -->
                    <div class="control-group">
                        <label for="midi-in-select">MIDI In:</label>
                        <select id="midi-in-select"><option value="">(No devices)</option></select>
                        <button id="midi-in-toggle-btn" class="control-button" style="font-size:0.8em; padding: 5px 8px;">Off</button>
                    </div>
                    <div class="control-group">
                        <label for="midi-out-select">MIDI Out:</label>
                        <select id="midi-out-select"><option value="">(No devices)</option></select>
                        <button id="midi-out-toggle-btn" class="control-button" style="font-size:0.8em; padding: 5px 8px;">Off</button>
                    </div>
                     <div class="control-group">
                        <label for="midi-mod-wheel-select">Mod Wheel:</label>
                        <select id="midi-mod-wheel-select">
                            <option value="none">None</option>
                            <option value="keys_vol">Keys Volume</option>
                            <option value="seq_vol">Sequencer Volume</option>
                            <option value="tempo">Tempo</option>
                            <option value="pitch">Global Pitch</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <button id="mute-all-btn" class="control-button" style="background-color: #c0392b; color: white;">Mute All</button>
                    </div>
                </div>

                <div class="controls-waveform-container">
                    <div class="top-controls-row">
                        <div class="octave-controls">
                            <button id="octave-down-btn" class="control-button">&ndash; Oct</button>
                            <span id="octave-display">Oct: 0</span>
                            <button id="octave-up-btn" class="control-button">+ Oct</button>
                        </div>
                         <div class="pitch-controls">
                            <label for="pitch-shift-slider">Pitch:</label>
                            <input type="range" id="pitch-shift-slider" min="-2" max="2" value="0" step="0.01">
                            <span id="pitch-shift-display">0.00 st</span>
                        </div>
                        <div class="zoom-controls">
                            <label for="zoom-slider">Zoom:</label>
                            <input type="range" id="zoom-slider" min="40" max="120" value="65" step="5">
                        </div>
                    </div>
                    <canvas id="waveform-canvas"></canvas>
                    <div id="interval-display-line-container" style="display: none;">
                        <div id="interval-display-line"></div>
                    </div>
                </div>
                <div class="keys-scroller">
                    <div class="piano-keys-container" id="piano-keys-container">
                        <!-- Piano key rows will be generated here -->
                    </div>
                </div>
            </div>
        </div>

        <details class="collapsible-section" open>
            <summary class="collapsible-section-summary">Chord & Arpeggio Controls</summary>
            <div class="chord-controls-container">
                <div class="chord-config-row">
                     <div class="control-group">
                        <label for="num-chords-input">Number of Chords:</label>
                        <input type="number" id="num-chords-input" value="4" min="1" max="10">
                        <button id="apply-num-chords-btn" class="control-button" style="font-size:0.8em; padding: 5px 8px;">Apply Chords</button>
                    </div>
                </div>
                <div class="chord-buttons-row" id="chord-buttons-row">
                    <!-- Chord definition groups will be generated here by JS -->
                </div>
                <button id="arp-toggle-btn" class="control-button">Arp: Off</button>
            </div>
        </details>

        <details class="collapsible-section" open>
            <summary class="collapsible-section-summary">Sequencer & Drums</summary>
            <div class="sequencer-section">
                <div class="sequencer-title">Dynamic Row Sequencer + Drums</div>
                <div class="sequencer-main-controls">
                    <button id="seq-play-stop-btn" class="control-button">Play</button>
                    <label for="seq-tempo-slider">Tempo:</label>
                    <input type="range" id="seq-tempo-slider" min="30" max="280" value="120" step="1">
                    <span id="seq-tempo-display">120 BPM</span>
                    <input type="number" id="seq-tempo-input" value="120" min="20" max="300" title="Tempo BPM">
                    <button id="tap-tempo-btn" class="control-button">Tap Tempo</button>
                    
                    <label for="num-seq-steps-input">Steps:</label>
                    <input type="number" id="num-seq-steps-input" value="16" min="4" max="64" step="1">
                    <button id="apply-seq-steps-btn" class="control-button" style="font-size:0.8em; padding: 5px 8px;">Apply Steps</button>
                    <label for="num-seq-rows-input">Melodic Rows:</label>
                    <input type="number" id="num-seq-rows-input" value="4" min="0" max="13"> 
                    <button id="apply-seq-rows-btn" class="control-button" style="font-size:0.8em; padding: 5px 8px;">Apply Rows</button>
                </div>
                <div class="sequencer-grid-container" id="sequencer-grid">
                    <!-- Sequencer rows/steps will be generated here -->
                </div>
                <div class="sequencer-file-ops">
             <!--    <button id="save-sequence-btn" class="control-button">Save Session</button>
                    <input type="file" id="load-sequence-input" accept=".json" style="display: none;">
                    <button id="load-sequence-btn" class="control-button">Load Session</button>      -->
                    <button id="export-midi-btn" class="control-button">Export MIDI</button>
                </div>
            </div>
        </details>
    </div>

    <script>
        const NOTE_NAMES = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        const BASE_FREQUENCIES_C4_OCTAVE = { // Used as a fallback and for initial C4 frequency
            "C": 261.63, "C#": 277.18, "D": 293.66, "D#": 311.13, "E": 329.63, 
            "F": 349.23, "F#": 369.99, "G": 392.00, "G#": 415.30, "A": 440.00, 
            "A#": 466.16, "B": 493.88
        };
        const JUST_INTONATION_RATIOS = [
            1/1,     // C
            16/15,   // C#/Db
            9/8,     // D
            6/5,     // D#/Eb
            5/4,     // E
            4/3,     // F
            45/32,   // F#/Gb
            3/2,     // G
            8/5,     // G#/Ab
            5/3,     // A
            16/9,    // A#/Bb
            15/8     // B
        ];
        const DEFAULT_INTERVAL_RATIOS = [ 
            "1/1", "16/15", "9/8", "6/5", "5/4", "4/3", "45/32", 
            "3/2", "8/5", "5/3", "16/9", "15/8" 
        ]; 
        let keysData = []; 

        let audioContext;
        let keysMasterGain, sequencerMasterGain; 
        let currentRootNoteName = "C";
        let currentRootFrequency = BASE_FREQUENCIES_C4_OCTAVE["C"];
        const activeOscillators = {}; 
        let NUM_PIANO_KEYS = 13; 
        let currentMaxKeysPerRow = 13; 

        let rootCFrequency = BASE_FREQUENCIES_C4_OCTAVE["C"];
        let masterRootNoteRatios = [...JUST_INTONATION_RATIOS];
        let rootNoteRatios = [...masterRootNoteRatios];
        let currentBaseFrequencies = { ...BASE_FREQUENCIES_C4_OCTAVE };
        let isRootDynamic = false;

        const rootSelectorDiv = document.querySelector('.root-selector');
        const pianoKeysContainerDiv = document.getElementById('piano-keys-container'); 
        const zoomSlider = document.getElementById('zoom-slider');
        
        let currentOctaveOffset = 0;
        const MIN_OCTAVE_OFFSET = -2;
        const MAX_OCTAVE_OFFSET = 2;
        let octaveUpBtn, octaveDownBtn, octaveDisplaySpan;

        let globalPitchShiftSemitones = 0;
        let pitchShiftSlider, pitchShiftDisplay;

        let analyserNode, waveformCanvas, waveformCtx, waveformDataArray, waveformAnimationId;
        let intervalDisplayLineContainer;

        let NUM_CHORDS = 4;
        let chordDefinitions = {};
        
        let isArpeggioActive = false;
        let activeChordSounds = []; 
        let highlightedChordKeys = []; 

        let arpLoopIntervalId = null;
        let currentArpChordType = null;
        let currentArpNoteIndex = 0;
        let currentArpSoundId = null;
        let currentArpPlayingKeyElement = null;

        const NUM_DRUM_ROWS = 3;
        const DRUM_ROW_NAMES = ["Kick", "Snare", "Hi-Hat"]; 
        const DRUM_WAV_FILES = ["kick.wav", "snare.wav", "hi-hat.wav"];
        const DRUM_FALLBACK_SYNTHS = ["kick_drum", "synth_snare", "hi_hat_noise"]; 
        const drumSamples = { "Kick": null, "Snare": null, "Hi-Hat": null };
        const DRUM_SAMPLES_PATH = ""; 

        let NUM_SEQ_MELODIC_ROWS = 4; 
        let NUM_SEQ_STEPS = 16; 
        let sequencerData = Array(NUM_DRUM_ROWS + NUM_SEQ_MELODIC_ROWS).fill(null).map(() => Array(NUM_SEQ_STEPS).fill(false));
        let SEQ_ROW_KEY_INDICES = Array(NUM_SEQ_MELODIC_ROWS).fill(0).map((_, i) => i % (NUM_PIANO_KEYS || 1)); 
        
        let currentSeqTempoBPM = 120;
        let isSequencerPlaying = false;
        let currentSeqStep = 0;
        let seqIntervalId = null;
        let lastTapTime = 0;
        let tapTempoCount = 0;

        let currentSoundTypeKeys = 'sine'; 
        let currentSoundTypeSeq = 'pluck_saw'; 

        let numPianoKeysInput, applyPianoKeysBtn;
        let maxKeysPerRowInput, applyMaxKeysRowBtn; 
        
        let numChordsInput, applyNumChordsBtn; 
        let chordButtonsRowDiv; 
        let arpToggleBtn;

        let seqPlayStopBtn, seqTempoSlider, seqTempoDisplay, seqTempoInput, tapTempoBtn;
        let numSeqStepsInput, applySeqStepsBtn;
        let numSeqRowsInput, applySeqRowsBtn; 
        let sequencerGridDiv;
        let keysVolumeSlider, sequencerVolumeSlider;
        let soundTypeKeysSelect, soundTypeSeqSelect;
        let exportSoundDefsBtn, importSoundDefsInput, importSoundDefsBtn;
        
        let midiAccess = null;
        let midiInSelect, midiOutSelect, midiInToggleButton, midiOutToggleButton, modWheelSelect;
        let isMidiInActive = false, isMidiOutActive = false;
        let selectedMidiInput = null, selectedMidiOutput = null;
        let modWheelTarget = 'none';
        const PITCH_BEND_RANGE_SEMITONES = 2;

        let skinSelect, keyShapeSelect, edoInput, applyTuningBtn;
        let currentSkin = 'skin-dark-space';
        let currentKeyShape = 'shape-rectangle';
        let draggedKeyIndex = null;
        
        let isKeyEditMode = true;
        let areRowsStaggered = false;
        let isEdoModeActive = false;


        let soundDefinitionFunctionBody = `
    let mainOsc, mainGain, filterNode, modulatorOsc, modulatorGain, noiseSource, lfo, lfoGain;
    let isSelfStopping = false;
    let soundNaturalDuration = 0.1; 

    switch (soundType) {
        case 'pluck_triangle': 
            mainGain = audioContext.createGain();
            mainOsc = audioContext.createOscillator();
            mainOsc.type = 'triangle';
            mainOsc.connect(mainGain);
            soundNaturalDuration = 0.25 + Math.random() * 0.1; 
            mainGain.gain.setValueAtTime(0, now);
            mainGain.gain.linearRampToValueAtTime(0.7, now + 0.005); 
            mainGain.gain.exponentialRampToValueAtTime(0.001, now + soundNaturalDuration);
            isSelfStopping = true;
            mainOsc.frequency.setValueAtTime(frequency, now);
            mainOsc.start(now);
            break;
        case 'pluck_saw': 
            mainGain = audioContext.createGain();
            mainOsc = audioContext.createOscillator();
            mainOsc.type = 'sawtooth';
            filterNode = audioContext.createBiquadFilter();
            filterNode.type = 'lowpass';
            filterNode.Q.setValueAtTime(1, now);
            mainOsc.connect(filterNode);
            filterNode.connect(mainGain);
            mainGain.gain.setValueAtTime(0, now);
            mainGain.gain.linearRampToValueAtTime(0.5, now + 0.01); 
            mainGain.gain.exponentialRampToValueAtTime(0.2, now + 0.1); 
            mainGain.gain.exponentialRampToValueAtTime(0.1, now + 0.3); 
            filterNode.frequency.setValueAtTime(5000, now);
            filterNode.frequency.exponentialRampToValueAtTime(300, now + 0.15);
            filterNode.frequency.exponentialRampToValueAtTime(200, now + 0.4);
            mainOsc.frequency.setValueAtTime(frequency, now);
            mainOsc.start(now);
            soundNaturalDuration = 0.4; 
            break;
        case 'warm_saw':
            mainGain = audioContext.createGain();
            mainOsc = audioContext.createOscillator();
            mainOsc.type = 'sawtooth';
            filterNode = audioContext.createBiquadFilter();
            filterNode.type = 'lowpass';
            filterNode.frequency.setValueAtTime(800, now);
            filterNode.Q.setValueAtTime(0.7, now);
            mainOsc.connect(filterNode);
            filterNode.connect(mainGain);
            mainGain.gain.setValueAtTime(0, now);
            mainGain.gain.linearRampToValueAtTime(0.4, now + 0.02); 
            mainOsc.frequency.setValueAtTime(frequency, now);
            mainOsc.start(now);
            break;
        
        case 'bell':
            mainGain = audioContext.createGain();
            mainGain.gain.setValueAtTime(0, now);
            mainGain.gain.linearRampToValueAtTime(0.4, now + 0.005); 
            mainGain.gain.exponentialRampToValueAtTime(0.0001, now + 1.5); 
            isSelfStopping = true;
            soundNaturalDuration = 1.5;
            
            let oscBell1 = audioContext.createOscillator();
            oscBell1.type = 'sine';
            oscBell1.frequency.setValueAtTime(frequency, now);
            oscBell1.connect(mainGain);
            oscBell1.start(now);
            activeOscillators[\`\${soundId}_aux1\`] = { oscillator: oscBell1, gainNode: null };

            let oscBell2 = audioContext.createOscillator();
            oscBell2.type = 'triangle'; 
            oscBell2.frequency.setValueAtTime(frequency * 2.4, now); 
            let gainBell2 = audioContext.createGain();
            gainBell2.gain.setValueAtTime(0.2, now); 
            oscBell2.connect(gainBell2);
            gainBell2.connect(mainGain);
            oscBell2.start(now);
            activeOscillators[\`\${soundId}_aux2\`] = { oscillator: oscBell2, gainNode: gainBell2 };

            let oscBell3 = audioContext.createOscillator();
            oscBell3.type = 'sine';
            oscBell3.frequency.setValueAtTime(frequency * 3.6, now); 
            let gainBell3 = audioContext.createGain();
            gainBell3.gain.setValueAtTime(0.1, now);
            oscBell3.connect(gainBell3);
            gainBell3.connect(mainGain);
            oscBell3.start(now);
            activeOscillators[\`\${soundId}_aux3\`] = { oscillator: oscBell3, gainNode: gainBell3 };
            
            mainOsc = oscBell1; 
            break;

        case 'soft_pad':
            mainGain = audioContext.createGain(); 
            mainGain.gain.setValueAtTime(0, now);
            mainGain.gain.linearRampToValueAtTime(0.3, now + 0.8);

            filterNode = audioContext.createBiquadFilter();
            filterNode.type = 'lowpass';
            filterNode.frequency.setValueAtTime(1000, now);
            filterNode.Q.setValueAtTime(0.5, now);
            filterNode.connect(mainGain); 

            let sp_oscPad1 = audioContext.createOscillator();
            sp_oscPad1.type = 'sawtooth';
            sp_oscPad1.frequency.setValueAtTime(frequency, now);
            sp_oscPad1.detune.setValueAtTime(-5, now);
            sp_oscPad1.connect(filterNode); 
            sp_oscPad1.start(now);
            activeOscillators[\`\${soundId}_aux1\`] = { oscillator: sp_oscPad1, gainNode: null };

            let sp_oscPad2 = audioContext.createOscillator();
            sp_oscPad2.type = 'sawtooth';
            sp_oscPad2.frequency.setValueAtTime(frequency, now);
            sp_oscPad2.detune.setValueAtTime(5, now);
            sp_oscPad2.connect(filterNode); 
            sp_oscPad2.start(now);
            activeOscillators[\`\${soundId}_aux2\`] = { oscillator: sp_oscPad2, gainNode: null };
            
            mainOsc = sp_oscPad1; 
            break;

        case 'xylophone':
            mainGain = audioContext.createGain();
            mainOsc = audioContext.createOscillator(); 
            mainOsc.type = 'sine';
            mainOsc.frequency.setValueAtTime(frequency, now); 
            mainOsc.connect(mainGain);

            modulatorOsc = audioContext.createOscillator(); 
            modulatorOsc.type = 'sine';
            modulatorOsc.frequency.setValueAtTime(frequency * 1.5, now); 

            modulatorGain = audioContext.createGain(); 
            modulatorGain.gain.setValueAtTime(0, now);
            modulatorGain.gain.linearRampToValueAtTime(frequency * 2, now + 0.01); 
            modulatorGain.gain.exponentialRampToValueAtTime(frequency * 0.5, now + 0.1); 
            modulatorGain.gain.exponentialRampToValueAtTime(1, now + 0.3);

            modulatorOsc.connect(modulatorGain);
            modulatorGain.connect(mainOsc.frequency); 

            mainGain.gain.setValueAtTime(0, now);
            mainGain.gain.linearRampToValueAtTime(0.5, now + 0.01); 
            mainGain.gain.exponentialRampToValueAtTime(0.001, now + 0.3); 
            isSelfStopping = true;
            soundNaturalDuration = 0.35;

            mainOsc.start(now);
            modulatorOsc.start(now);
            break;
        
        case 'lead_square':
            mainGain = audioContext.createGain();
            mainOsc = audioContext.createOscillator();
            mainOsc.type = 'square';
            filterNode = audioContext.createBiquadFilter();
            filterNode.type = 'lowpass';
            filterNode.Q.setValueAtTime(5, now); 
            mainOsc.connect(filterNode);
            filterNode.connect(mainGain); 

            mainGain.gain.setValueAtTime(0, now);
            mainGain.gain.linearRampToValueAtTime(0.3, now + 0.01); 

            filterNode.frequency.setValueAtTime(100, now); 
            filterNode.frequency.exponentialRampToValueAtTime(3000, now + 0.05); 
            filterNode.frequency.exponentialRampToValueAtTime(800, now + 0.2);   
            
            mainOsc.frequency.setValueAtTime(frequency, now);
            mainOsc.start(now);
            break;

        case 'organ':
            mainGain = audioContext.createGain();
            mainGain.gain.setValueAtTime(0, now);
            mainGain.gain.linearRampToValueAtTime(0.2, now + 0.01); 

            const organHarmonics = [1, 2, 3, 4, 6]; 
            const organGains = [1, 0.6, 0.4, 0.3, 0.2];
            
            organHarmonics.forEach((harmonic, index) => {
                let osc = audioContext.createOscillator();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(frequency * harmonic, now);
                let gain = audioContext.createGain();
                gain.gain.setValueAtTime(organGains[index], now);
                osc.connect(gain);
                gain.connect(mainGain); 
                osc.start(now);
                activeOscillators[\`\${soundId}_harm\${index}\`] = { oscillator: osc, gainNode: gain };
                if (index === 0) mainOsc = osc; 
            });
            break;

        case 'kick_drum': 
            mainGain = audioContext.createGain();
            mainOsc = audioContext.createOscillator();
            mainOsc.type = 'sine';
            
            mainGain.gain.setValueAtTime(0, now);
            mainGain.gain.linearRampToValueAtTime(0.8, now + 0.005); 
            mainGain.gain.exponentialRampToValueAtTime(0.001, now + 0.2); 
            isSelfStopping = true;
            soundNaturalDuration = 0.2;

            mainOsc.frequency.setValueAtTime(150, now); 
            mainOsc.frequency.exponentialRampToValueAtTime(50, now + 0.05); 
            mainOsc.connect(mainGain);
            mainOsc.start(now);
            break;
        
        case 'hi_hat_noise':
            mainGain = audioContext.createGain();
            const bufferSize = audioContext.sampleRate * 0.1; 
            const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const output = noiseBuffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                output[i] = Math.random() * 2 - 1; 
            }
            noiseSource = audioContext.createBufferSource();
            noiseSource.buffer = noiseBuffer;

            filterNode = audioContext.createBiquadFilter();
            filterNode.type = 'highpass';
            filterNode.frequency.setValueAtTime(7000, now); 
            noiseSource.connect(filterNode);
            filterNode.connect(mainGain); 

            mainGain.gain.setValueAtTime(0, now);
            mainGain.gain.linearRampToValueAtTime(0.3, now + 0.002); 
            mainGain.gain.exponentialRampToValueAtTime(0.0001, now + 0.05); 
            isSelfStopping = true;
            soundNaturalDuration = 0.05;
            noiseSource.start(now);
            mainOsc = null; 
            break;

        case 'synth_snare':
            mainGain = audioContext.createGain();
            mainGain.gain.setValueAtTime(0, now); // Overall gain envelope starts at 0

            // Noise component
            const noiseBufferSize = audioContext.sampleRate * 0.2; // 200ms white noise
            const snareNoiseBuffer = audioContext.createBuffer(1, noiseBufferSize, audioContext.sampleRate);
            const noiseOutput = snareNoiseBuffer.getChannelData(0);
            for (let i = 0; i < noiseBufferSize; i++) {
                noiseOutput[i] = Math.random() * 2 - 1;
            }
            const snareNoiseSource = audioContext.createBufferSource();
            snareNoiseSource.buffer = snareNoiseBuffer;

            const noiseFilter = audioContext.createBiquadFilter();
            noiseFilter.type = 'bandpass';
            noiseFilter.frequency.setValueAtTime(3000, now); // Center frequency for sizzle
            noiseFilter.Q.setValueAtTime(1, now);

            const noiseGain = audioContext.createGain();
            noiseGain.gain.setValueAtTime(0, now);
            noiseGain.gain.linearRampToValueAtTime(0.5, now + 0.005); // Quick attack for noise
            noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.1); // Short decay for noise

            snareNoiseSource.connect(noiseFilter);
            noiseFilter.connect(noiseGain);
            noiseGain.connect(mainGain);
            snareNoiseSource.start(now);
            activeOscillators[\`\${soundId}_noise\`] = { oscillator: snareNoiseSource, gainNode: noiseGain, filterNode: noiseFilter };

            // Tonal component (body)
            const bodyOsc = audioContext.createOscillator();
            bodyOsc.type = 'triangle';
            // Use the passed frequency for the body, or default if not sensible
            const bodyFreq = (frequency && frequency > 50 && frequency < 800) ? frequency : 200;
            bodyOsc.frequency.setValueAtTime(bodyFreq, now); // Pitch of the snare body
            bodyOsc.frequency.exponentialRampToValueAtTime(bodyFreq * 0.6, now + 0.08); // Quick pitch drop

            const bodyGain = audioContext.createGain();
            bodyGain.gain.setValueAtTime(0, now);
            bodyGain.gain.linearRampToValueAtTime(0.6, now + 0.01); // Slightly slower attack for body
            bodyGain.gain.exponentialRampToValueAtTime(0.001, now + 0.15); // Slightly longer decay for body

            bodyOsc.connect(bodyGain);
            bodyGain.connect(mainGain);
            bodyOsc.start(now);
            mainOsc = bodyOsc; // Assign one oscillator as 'main' for consistency, though noise is important
            activeOscillators[\`\${soundId}_body\`] = { oscillator: bodyOsc, gainNode: bodyGain };

            // Overall envelope for the mixed sound
            // This is applied to mainGain, which sums noise and body
            mainGain.gain.setValueAtTime(0.0, now); // Ensure it starts silent
            mainGain.gain.linearRampToValueAtTime(0.7, now + 0.01); // Master attack
            mainGain.gain.exponentialRampToValueAtTime(0.001, now + 0.2); // Master decay
            
            isSelfStopping = true;
            soundNaturalDuration = 0.2; // Duration for the entire snare sound
            break;

        
        case 'synth':
            mainGain = audioContext.createGain();
            mainOsc = audioContext.createOscillator();
            mainOsc.type = 'sawtooth'; 
            
            filterNode = audioContext.createBiquadFilter(); 
            filterNode.type = 'lowpass';
            filterNode.frequency.setValueAtTime(frequency * 3, now); 
            filterNode.Q.setValueAtTime(0.8, now);

            lfo = audioContext.createOscillator(); 
            lfo.type = 'square';
            lfo.frequency.setValueAtTime(8, now); 
            lfoGain = audioContext.createGain();
            lfoGain.gain.setValueAtTime(8, now); 
            lfo.connect(lfoGain);
            lfoGain.connect(mainOsc.detune); 

            mainOsc.connect(filterNode);
            filterNode.connect(mainGain); 

            mainGain.gain.setValueAtTime(0, now);
            mainGain.gain.linearRampToValueAtTime(0.4, now + 0.05); 

            mainOsc.frequency.setValueAtTime(frequency, now);
            mainOsc.start(now);
            lfo.start(now);
            break;

        case 'sine':
        default:
            mainGain = audioContext.createGain();
            mainOsc = audioContext.createOscillator();
            mainOsc.type = 'sine';
            mainOsc.connect(mainGain);
            mainGain.gain.setValueAtTime(0, now);
            mainGain.gain.linearRampToValueAtTime(0.3, now + 0.02); 
            mainOsc.frequency.setValueAtTime(frequency, now);
            mainOsc.start(now);
            break;
    }
    return { mainOsc, mainGain, filterNode, modulatorOsc, modulatorGain, noiseSource, lfo, lfoGain, isSelfStopping, soundNaturalDuration };
`;
        let currentSoundGenerator = new Function(
            'soundType', 'frequency', 'now', 'audioContext', 'masterGainNode', 'soundId', 'activeOscillators',
            soundDefinitionFunctionBody
        );

        const activeKeyboardNotes = {}; 
        const ROOT_NOTE_KEY_MAP = { 
            '1':'C', '2':'C#', '3':'D', '4':'D#', '5':'E', '6':'F', 
            '7':'F#', '8':'G', '9':'G#', '0':'A', '=':'A#', '?':'B' 
        };
        const PIANO_KEY_COMPUTER_KEY_MAP = [ 
            'q','w','e','r','t','y','u','i','o','p',
            'a','s','d','f','g','h','j','k','l',
            'z','x','c','v','b','n','m',',','.'
        ];

        function gcd(a, b) { 
            a = Math.abs(Math.round(a)); 
            b = Math.abs(Math.round(b));
            if (b === 0) return a;
            return gcd(b, a % b);
        }
        
        function decimalToFractionString(decimal, maxDenominator = 256) {
            if (decimal === undefined || isNaN(decimal)) return "1/1"; 
            if (decimal % 1 === 0 && decimal !== 0) return `${decimal}/1`;
            if (decimal === 0) return "0/1";

            let bestN = Math.round(decimal * maxDenominator);
            let bestD = maxDenominator;
            let minError = Infinity;

            for (let d_try = 1; d_try <= maxDenominator; d_try++) {
                const n_try = Math.round(decimal * d_try);
                if (n_try === 0 && Math.abs(decimal) > 1e-9) continue; 
                
                const currentError = Math.abs(decimal - n_try / d_try);
                if (currentError < minError) {
                    minError = currentError;
                    bestN = n_try;
                    bestD = d_try;
                }
                if (minError < 1e-9) break; 
            }
            const common = gcd(bestN, bestD);
            const finalN = bestN / common;
            const finalD = bestD / common;

            if (finalD === 1) return `${finalN}`; 
            return `${finalN}/${finalD}`;
        }
        
        function getEffectiveIntervalString(keyIndex) {
            if (keyIndex < 0 || keyIndex >= keysData.length || !keysData[keyIndex]) {
                return "1/1";
            }
            const baseIntervalStrForKey = keysData[keyIndex].interval || "1/1";
            
            let n_str, d_str;
            const parts = baseIntervalStrForKey.split('/');
            if (parts.length === 1) { n_str = parts[0]; d_str = "1"; }
            else if (parts.length === 2) { n_str = parts[0]; d_str = parts[1]; }
            else { n_str = "1"; d_str = "1"; } 

            let n = parseFloat(n_str);
            let d = parseFloat(d_str);
            if (isNaN(n) || isNaN(d) || d === 0) { n = 1; d = 1; }

            const implicitOctaveShift = Math.floor(keyIndex / 12);
            const totalOctaveShift = implicitOctaveShift + currentOctaveOffset;

            if (totalOctaveShift > 0) { n *= Math.pow(2, totalOctaveShift); }
            else if (totalOctaveShift < 0) { d *= Math.pow(2, -totalOctaveShift); }

            let tempN = n;
            let tempD = d;
            let factor = 1;
            while( (tempN % 1 !== 0 || tempD % 1 !== 0) && factor < 100000 ) {
                factor *= 10;
                tempN = n * factor;
                tempD = d * factor;
            }
            n = Math.round(tempN);
            d = Math.round(tempD);

            const commonDivisor = gcd(n, d);
            let final_n = n / commonDivisor;
            let final_d = d / commonDivisor;

            if (final_d < 0) { final_n = -final_n; final_d = -final_d; } 

            return (final_d === 1) ? `${final_n}` : `${final_n}/${final_d}`;
        }

        async function loadDrumSamples() {
            if (!audioContext) return;
            for (let i = 0; i < NUM_DRUM_ROWS; i++) {
                const drumName = DRUM_ROW_NAMES[i];
                const wavFile = DRUM_WAV_FILES[i];
                try {
                    const response = await fetch(DRUM_SAMPLES_PATH + wavFile);
                    if (!response.ok) {
                        console.warn(`Could not fetch ${wavFile}. Status: ${response.status}. Using synth fallback for ${drumName}.`);
                        drumSamples[drumName] = null;
                        continue;
                    }
                    const arrayBuffer = await response.arrayBuffer();
                    const buffer = await new Promise((resolve, reject) => {
                        audioContext.decodeAudioData(arrayBuffer, resolve, reject);
                    });
                    drumSamples[drumName] = buffer;
                    console.log(`${wavFile} loaded successfully for ${drumName}.`);
                } catch (error) {
                    console.error(`Error loading or decoding ${wavFile} for ${drumName}:`, error, `. Using synth fallback.`);
                    drumSamples[drumName] = null;
                }
            }
        }

        async function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                keysMasterGain = audioContext.createGain();
                sequencerMasterGain = audioContext.createGain();
                analyserNode = audioContext.createAnalyser();
                analyserNode.fftSize = 2048;
                waveformDataArray = new Uint8Array(analyserNode.frequencyBinCount);
                keysMasterGain.connect(analyserNode);
                sequencerMasterGain.connect(analyserNode);
                analyserNode.connect(audioContext.destination); 
                waveformCanvas = document.getElementById('waveform-canvas');
                if (waveformCanvas) waveformCtx = waveformCanvas.getContext('2d');
                intervalDisplayLineContainer = document.getElementById('interval-display-line-container');

                
                await loadDrumSamples(); 
            }
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }

        function parseRatio(ratioStr) {
            if (typeof ratioStr !== 'string') return 1;
            if (ratioStr.includes('/')) {
                const parts = ratioStr.split('/');
                const num = parseFloat(parts[0]);
                const den = parseFloat(parts[1]);
                if (den === 0 || isNaN(num) || isNaN(den)) return 1;
                return num / den;
            }
            const val = parseFloat(ratioStr);
            return isNaN(val) ? 1 : val;
        }

        function getFrequencyForKey(keyIndex, octaveModifier = 0) {
            if (keyIndex < 0 || keyIndex >= NUM_PIANO_KEYS || !keysData[keyIndex]) return null;
            
            const baseIntervalStringForKey = keysData[keyIndex].interval || DEFAULT_INTERVAL_RATIOS[keyIndex % DEFAULT_INTERVAL_RATIOS.length];
            const intervalRatio = parseRatio(baseIntervalStringForKey);
            const implicitOctaveShift = Math.floor(keyIndex / 12); 
            const baseFrequencyForKey = currentRootFrequency * intervalRatio;
            
            const octaveShiftedFreq = baseFrequencyForKey * Math.pow(2, currentOctaveOffset + octaveModifier + implicitOctaveShift);
            const finalFreq = octaveShiftedFreq * Math.pow(2, globalPitchShiftSemitones / 12);
            
            return {
                finalFreq: finalFreq,
                baseFreq: octaveShiftedFreq
            };
        }

        function applyZoom(keyWidthValue) {
            const numKeyWidth = parseFloat(keyWidthValue);
            document.documentElement.style.setProperty('--key-width', `${numKeyWidth}px`);
            document.querySelectorAll('.piano-key').forEach(key => {
                key.style.width = `${numKeyWidth}px`;
            });
            document.querySelectorAll('.interval-input').forEach(input => {
                const newIntervalInputWidth = Math.max(30, Math.min(numKeyWidth - 10, 55));
                input.style.width = `${newIntervalInputWidth}px`;
            });
        }
        
        function updateOctaveDisplay() {
            if (!octaveDisplaySpan || !octaveUpBtn || !octaveDownBtn) return;
            octaveDisplaySpan.textContent = `Oct: ${currentOctaveOffset >= 0 ? '+' : ''}${currentOctaveOffset}`;
            octaveUpBtn.disabled = currentOctaveOffset >= MAX_OCTAVE_OFFSET;
            octaveDownBtn.disabled = currentOctaveOffset <= MIN_OCTAVE_OFFSET;
            updateKeyDisplays(); 
            for (const chordType in chordDefinitions) {
                createChordKeySelectors(chordType);
            }
        }
        
        let keyIdCounter = 0;
        function generateKeyId() {
            return Date.now() + (keyIdCounter++);
        }
        
        function resizeKeyDataArray() {
            const oldKeysData = [...keysData];
            keysData = [];
            for (let i = 0; i < NUM_PIANO_KEYS; i++) {
                if (i < oldKeysData.length) {
                    keysData.push(oldKeysData[i]); // Copy old data (key object or null)
                } else {
                     // This is a new slot because we're expanding
                    keysData.push({
                        id: generateKeyId(),
                        interval: DEFAULT_INTERVAL_RATIOS[i % DEFAULT_INTERVAL_RATIOS.length]
                    });
                }
            }
        }

        function handleApplyPianoKeys() {
            const newNumKeys = parseInt(numPianoKeysInput.value, 10);
            if (isNaN(newNumKeys) || newNumKeys < 1 || newNumKeys > 61) { 
                alert("Number of key slots must be between 1 and 61.");
                numPianoKeysInput.value = NUM_PIANO_KEYS; 
                return;
            }
            NUM_PIANO_KEYS = newNumKeys;
            resizeKeyDataArray(); 

            remapAllIndices(NUM_PIANO_KEYS > 0 ? NUM_PIANO_KEYS - 1 : -1);
            
            createPianoKeysAndRootSelector(); 
            createSequencerGrid(); 
            updateKeyDisplays(); 
        }

        function remapAllIndices(maxIndex) {
            for (const type in chordDefinitions) {
                if (chordDefinitions[type]) {
                     chordDefinitions[type].currentKeyIndices = chordDefinitions[type].currentKeyIndices.map(ki => {
                        if (ki === null) return null; 
                        let newIndexValue;
                        if (typeof ki === 'object') { 
                            newIndexValue = Math.max(0, Math.min(ki.keyIndex, maxIndex));
                            return { ...ki, keyIndex: newIndexValue };
                        } else { 
                            newIndexValue = Math.max(0, Math.min(ki, maxIndex));
                            return newIndexValue;
                        }
                    }).slice(0, chordDefinitions[type].numNotes);
                    createChordKeySelectors(type); 
                }
            }

            SEQ_ROW_KEY_INDICES = SEQ_ROW_KEY_INDICES.map(idx => Math.min(idx, maxIndex));
        }


        function handleApplyMaxKeysPerRow() {
            const newMax = parseInt(maxKeysPerRowInput.value, 10);
            if (isNaN(newMax) || newMax < 1 || newMax > 25) { 
                alert("Max keys per row must be between 1 and 25.");
                maxKeysPerRowInput.value = currentMaxKeysPerRow;
                return;
            }
            currentMaxKeysPerRow = newMax;
            createPianoKeysAndRootSelector(); 
        }

        function createPianoKeysAndRootSelector() {
            rootSelectorDiv.innerHTML = ''; 
            NOTE_NAMES.forEach(noteName => {
                const button = document.createElement('button');
                button.classList.add('root-button');
                button.textContent = noteName;
                button.dataset.noteName = noteName;
                if (noteName === currentRootNoteName) button.classList.add('active');
                button.addEventListener('click', (e) => {
                    selectRootNote(noteName, e.target);
                });
                rootSelectorDiv.appendChild(button);
            });

            pianoKeysContainerDiv.innerHTML = ''; 
            if (keysData.length !== NUM_PIANO_KEYS) { 
                resizeKeyDataArray();
            }

            let currentKeyRowDiv;
            for (let i = 0; i < NUM_PIANO_KEYS; i++) {
                if (i % currentMaxKeysPerRow === 0) { 
                    currentKeyRowDiv = document.createElement('div');
                    currentKeyRowDiv.classList.add('piano-keys-row');
                    pianoKeysContainerDiv.appendChild(currentKeyRowDiv);
                }

                const keyData = keysData[i];
                if (keyData === null) {
                    const placeholder = document.createElement('div');
                    placeholder.classList.add('key-placeholder');
                    placeholder.dataset.keyIndex = i;
                    placeholder.textContent = '+';
                    placeholder.title = 'Empty Slot - Click to add a key';
                    placeholder.addEventListener('dragover', handleDragOver);
                    placeholder.addEventListener('dragleave', handleDragLeave);
                    placeholder.addEventListener('drop', handleDrop);
                    placeholder.addEventListener('dragend', handleDragEnd);
                    placeholder.addEventListener('click', () => {
                        if (isKeyEditMode) {
                            handleAddKey(i);
                        }
                    });
                    currentKeyRowDiv.appendChild(placeholder);
                    continue; 
                }

                const keyWrapper = document.createElement('div');
                keyWrapper.classList.add('key-wrapper');
                keyWrapper.dataset.keyIndex = i;
                
                keyWrapper.draggable = isKeyEditMode;
                keyWrapper.addEventListener('dragstart', handleDragStart);
                keyWrapper.addEventListener('dragover', handleDragOver);
                keyWrapper.addEventListener('dragleave', handleDragLeave);
                keyWrapper.addEventListener('drop', handleDrop);
                keyWrapper.addEventListener('dragend', handleDragEnd);

                const intervalInput = document.createElement('input');
                intervalInput.type = 'text';
                intervalInput.classList.add('interval-input');
                intervalInput.dataset.keyIndex = i;

                intervalInput.addEventListener('change', (event) => {
                    const inputEl = event.target;
                    const keyIndex = parseInt(inputEl.dataset.keyIndex);
                    const newEffectiveRatioStr = inputEl.value; 

                    let effN_str, effD_str;
                    const effParts = newEffectiveRatioStr.split('/');
                    if (effParts.length === 1) { effN_str = effParts[0]; effD_str = "1"; }
                    else if (effParts.length === 2) { effN_str = effParts[0]; effD_str = effParts[1]; }
                    else { alert("Invalid ratio format. Use 'N' or 'N/D'."); updateKeyDisplays(); return; } 

                    let effN = parseFloat(effN_str);
                    let effD = parseFloat(effD_str);

                    if (isNaN(effN) || isNaN(effD) || effD === 0) {
                        alert("Invalid numbers in ratio."); updateKeyDisplays(); return; 
                    }
                    const effectiveNumericRatio = effN / effD;
                    const implicitOctaveShift = Math.floor(keyIndex / 12);
                    const totalAppliedOctaveShift = implicitOctaveShift + currentOctaveOffset;

                    let baseNumericRatio = effectiveNumericRatio;
                    if (totalAppliedOctaveShift > 0) {
                        baseNumericRatio /= Math.pow(2, totalAppliedOctaveShift);
                    } else if (totalAppliedOctaveShift < 0) {
                        baseNumericRatio *= Math.pow(2, -totalAppliedOctaveShift);
                    }
                    if (keysData[keyIndex]) {
                        keysData[keyIndex].interval = decimalToFractionString(baseNumericRatio);
                    }
                    updateKeyDisplays(); 
                });
                
                const key = document.createElement('button');
                key.classList.add('piano-key');
                key.dataset.keyIndex = i;
                const noteNameSpan = document.createElement('span');
                noteNameSpan.classList.add('note-name');
                const intervalDisplaySpan = document.createElement('span');
                intervalDisplaySpan.classList.add('interval-display');
                key.appendChild(noteNameSpan);
                key.appendChild(intervalDisplaySpan);
                
                const playNoteHandler = async () => {
                    await initAudioContext(); 
                    const keyIndex = parseInt(key.dataset.keyIndex);
                    const freqObject = getFrequencyForKey(keyIndex);
                    if (freqObject === null) return;
                    playSound(freqObject, `key_${keyIndex}`, 'key');
                    key.classList.add('playing');
                };
                const stopNoteHandler = () => {
                    stopSound(`key_${parseInt(key.dataset.keyIndex)}`);
                    key.classList.remove('playing');
                };
                
                key.addEventListener('mousedown', playNoteHandler);
                key.addEventListener('mouseup', stopNoteHandler);
                key.addEventListener('mouseleave', () => { if (key.classList.contains('playing')) stopNoteHandler(); });
                key.addEventListener('touchstart', (e) => { e.preventDefault(); playNoteHandler(); });
                key.addEventListener('touchend', (e) => { e.preventDefault(); stopNoteHandler(); });
                
                const deleteBtn = document.createElement('button');
                deleteBtn.classList.add('delete-key-btn');
                deleteBtn.innerHTML = '&times;';
                deleteBtn.title = 'Delete Key';
                deleteBtn.dataset.keyIndex = i;
                deleteBtn.addEventListener('click', handleDeleteKey);

                keyWrapper.appendChild(intervalInput);
                keyWrapper.appendChild(key);
                keyWrapper.appendChild(deleteBtn);
                currentKeyRowDiv.appendChild(keyWrapper);
            }
            updateKeyDisplays();
            if (zoomSlider) applyZoom(zoomSlider.value);
        }

        function handleAddKey(keyIndex) {
            keysData[keyIndex] = {
                id: generateKeyId(),
                interval: decimalToFractionString(Math.pow(2, keyIndex / 12)) // Default to 12-EDO for the position
            };
            createPianoKeysAndRootSelector();
            updateKeyDisplays();
        }

        function handleDeleteKey(event) {
            const keyIndexToDelete = parseInt(event.target.dataset.keyIndex, 10);
            if (keyIndexToDelete === 0) {
                alert("The root key slot (Key 1) cannot be deleted.");
                return;
            }
            if (confirm(`Are you sure you want to delete key ${keyIndexToDelete + 1}? This will create an empty slot.`)) {
                keysData[keyIndexToDelete] = null;
                createPianoKeysAndRootSelector();
                updateKeyDisplays();
            }
        }
        
        function handleDragStart(e) {
            draggedKeyIndex = parseInt(e.target.dataset.keyIndex, 10);
            
            stopSound(`key_${draggedKeyIndex}`);
            stopSound(`keyboard_key_${draggedKeyIndex}`);

            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', draggedKeyIndex);
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            const target = e.target.closest('.key-wrapper, .key-placeholder');
            if (target) {
                target.classList.add('drag-over');
            }
        }
        
        function handleDragLeave(e) {
            const target = e.target.closest('.key-wrapper, .key-placeholder');
            if (target) {
                target.classList.remove('drag-over');
            }
        }

        function handleDrop(e) {
            e.preventDefault();
            const target = e.target.closest('.key-wrapper, .key-placeholder');
            if (target) {
                target.classList.remove('drag-over');
                const targetIndex = parseInt(target.dataset.keyIndex, 10);
                
                if (draggedKeyIndex !== null && draggedKeyIndex !== targetIndex) {
                    const draggedItem = keysData[draggedKeyIndex];
                    keysData[draggedKeyIndex] = keysData[targetIndex];
                    keysData[targetIndex] = draggedItem;
                    
                    createPianoKeysAndRootSelector();
                    updateKeyDisplays();
                }
            }
        }
        
        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            draggedKeyIndex = null;
            document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
        }

        async function selectRootNote(noteName, buttonElement = null) {
            await initAudioContext();

            if (isRootDynamic) {
                const rootIndex = NOTE_NAMES.indexOf(noteName);
                if (rootIndex !== -1) {
                    const newRootRatio = masterRootNoteRatios[rootIndex];
                    rootNoteRatios = masterRootNoteRatios.map(r => r / newRootRatio);
                    recalculateBaseFrequencies();
                    updateRootTuningInputs();
                }
            }

            currentRootNoteName = noteName;
            currentRootFrequency = currentBaseFrequencies[noteName];
            document.querySelectorAll('.root-button.active, .root-button.keyboard-active').forEach(b => {
                b.classList.remove('active');
                b.classList.remove('keyboard-active');
            });
            if (buttonElement) {
                buttonElement.classList.add('active');
            } else { 
                const targetButton = rootSelectorDiv.querySelector(`.root-button[data-note-name="${noteName}"]`);
                if (targetButton) targetButton.classList.add('keyboard-active');
            }
            updateKeyDisplays();
            for (const chordType in chordDefinitions) {
                createChordKeySelectors(chordType);
            }
        }

        function updateKeyDisplays() {
            const rootNoteIndex = NOTE_NAMES.indexOf(currentRootNoteName);
            document.querySelectorAll('.piano-key').forEach((keyElement) => { 
                const keyIndex = parseInt(keyElement.dataset.keyIndex);
                if (keyIndex >= keysData.length || !keysData[keyIndex]) return; 

                const intervalInputEl = document.querySelector(`.interval-input[data-key-index="${keyIndex}"]`);
                if (!intervalInputEl) return;

                const baseIntervalStrForKey = keysData[keyIndex].interval || "1/1";
                
                const baseIntervalForNoteName = parseRatio(baseIntervalStrForKey);
                const displaySemitonesFromRoot = Math.round(12 * Math.log2(baseIntervalForNoteName));
                const noteNameIndex = (rootNoteIndex + displaySemitonesFromRoot + 12 * 10) % 12; 
                const noteName = NOTE_NAMES[noteNameIndex]; 
                keyElement.querySelector('.note-name').textContent = noteName;

                if (noteName.includes("#") || noteName.includes("b")) {
                    keyElement.classList.add('sharp-flat-key');
                } else {
                    keyElement.classList.remove('sharp-flat-key');
                }

                const effectiveIntervalStr = getEffectiveIntervalString(keyIndex);
                intervalInputEl.value = effectiveIntervalStr;
                keyElement.querySelector('.interval-display').textContent = `(${effectiveIntervalStr})`;
            });
            
            document.querySelectorAll('.seq-row-key-select').forEach(select => {
                const currentVal = parseInt(select.value, 10);
                const melodicRowIndex = parseInt(select.dataset.rowIndex); 
                select.innerHTML = ''; 
                 for (let i = 0; i < NUM_PIANO_KEYS; i++) { 
                    if (!keysData[i]) continue; // Don't add null keys to selector
                    const option = document.createElement('option'); option.value = i;
                    const effectiveIntervalForSeqDisp = getEffectiveIntervalString(i); 
                    option.textContent = `Key ${i+1} (${effectiveIntervalForSeqDisp})`; 
                    select.appendChild(option);
                }
                if (keysData[currentVal]) { 
                    select.value = currentVal; 
                } else if (select.options.length > 0) {
                    const firstValidIndex = select.options[0].value;
                    select.value = firstValidIndex;
                    SEQ_ROW_KEY_INDICES[melodicRowIndex] = parseInt(firstValidIndex, 10);
                } else { 
                    select.value = ""; 
                    SEQ_ROW_KEY_INDICES[melodicRowIndex] = undefined;
                }
            });
            updateIntervalDisplayLine();
        }

        function updateIntervalDisplayLine() {
            if (!intervalDisplayLineContainer) return;

            const line = intervalDisplayLineContainer.querySelector('#interval-display-line');
            if (!line) return;
            line.innerHTML = ''; // Clear previous markers

            const keyDisplayData = [];
            for (let i = 0; i < NUM_PIANO_KEYS; i++) {
                if (!keysData[i]) continue; // Skip null/empty keys
                const freqObject = getFrequencyForKey(i);
                if (freqObject !== null && freqObject.baseFreq > 0) {
                    keyDisplayData.push({
                        freq: freqObject.baseFreq,
                        ratio: getEffectiveIntervalString(i)
                    });
                }
            }

            if (keyDisplayData.length < 2) {
                intervalDisplayLineContainer.style.display = 'none';
                return;
            }

            intervalDisplayLineContainer.style.display = 'flex';
            
            keyDisplayData.sort((a, b) => a.freq - b.freq);

            const minFreq = keyDisplayData[0].freq;
            const maxFreq = keyDisplayData[keyDisplayData.length - 1].freq;
            
            const minLog = Math.log(minFreq);
            const rangeLog = Math.log(maxFreq) - minLog;

            if (rangeLog <= 0) {
                 intervalDisplayLineContainer.style.display = 'none';
                 return;
            }

            const fragment = document.createDocumentFragment();

            keyDisplayData.forEach(data => {
                const posPercent = ((Math.log(data.freq) - minLog) / rangeLog) * 100;
                
                const marker = document.createElement('div');
                marker.className = 'interval-marker';
                
                const label = document.createElement('div');
                label.className = 'interval-marker-label';
                label.textContent = data.ratio;
                
                const wrapper = document.createElement('div');
                wrapper.style.position = 'absolute';
                wrapper.style.left = `${posPercent}%`;
                wrapper.style.height = '100%';
                wrapper.appendChild(marker);
                wrapper.appendChild(label);
                
                fragment.appendChild(wrapper);
            });
            line.appendChild(fragment);
        }
        
        function playSound(frequencyObject, soundId, source = 'key', noteOnDuration = null, forcedSoundType = null) {
            if (!audioContext || frequencyObject === null) return;
            const finalFrequency = frequencyObject.finalFreq;
            const baseFrequency = frequencyObject.baseFreq;

            if (activeOscillators[soundId]) stopSound(soundId, 0.01);

            const now = audioContext.currentTime;
            const masterGainNodeToUse = (source === 'sequencer' || source === 'sequencer_drum_synth') ? sequencerMasterGain : keysMasterGain;
            const soundTypeToUse = forcedSoundType || 
                                 ((source === 'sequencer') ? currentSoundTypeSeq : currentSoundTypeKeys);
            
            let soundElements;
            try {
                soundElements = currentSoundGenerator(
                    soundTypeToUse, finalFrequency, now, audioContext, masterGainNodeToUse, soundId, activeOscillators
                );
            } catch (e) {
                console.error(`Error generating sound '${soundTypeToUse}':`, e);
                const fallbackGain = audioContext.createGain();
                const fallbackOsc = audioContext.createOscillator();
                fallbackOsc.type = 'sine';
                if (finalFrequency !== null) fallbackOsc.frequency.setValueAtTime(finalFrequency, now);
                else fallbackOsc.frequency.setValueAtTime(440, now); 
                fallbackOsc.connect(fallbackGain);
                fallbackGain.gain.setValueAtTime(0, now);
                fallbackGain.gain.linearRampToValueAtTime(0.3, now + 0.02);
                fallbackOsc.start(now);
                soundElements = { 
                    mainOsc: fallbackOsc, mainGain: fallbackGain, 
                    isSelfStopping: false, soundNaturalDuration: 0.1 
                };
                alert(`Error in sound definition for '${soundTypeToUse}'. Playing a default sine wave. Check console for details.`);
            }

            let { mainOsc, mainGain, filterNode, modulatorOsc, modulatorGain, noiseSource, lfo, lfoGain, isSelfStopping, soundNaturalDuration } = soundElements;

            if (!mainGain) { 
                console.error(`Sound '${soundTypeToUse}' definition did not create/return 'mainGain'. Cannot play sound.`);
                return;
            }
            mainGain.connect(masterGainNodeToUse); 
            
            activeOscillators[soundId] = { 
                oscillator: mainOsc, gainNode: mainGain, filterNode: filterNode, source: source, 
                isSequencerNote: (noteOnDuration !== null), soundTypeUsed: soundTypeToUse, 
                modulatorOsc: modulatorOsc, modulatorGain: modulatorGain, noiseSource: noiseSource,
                lfo: lfo, lfoGain: lfoGain, baseFrequency: baseFrequency
            };

            if (isMidiOutActive && selectedMidiOutput && (source.startsWith('key') || source.startsWith('keyboard_key'))) {
                const soundObject = activeOscillators[soundId];
                if (soundObject && finalFrequency) {
                    const keyIndexMatch = soundId.match(/\d+$/);
                    if (keyIndexMatch) {
                        const keyIndex = parseInt(keyIndexMatch[0], 10);
                        const midiChannel = keyIndex % 16;
                        
                        const midiNoteValue = 69 + 12 * Math.log2(finalFrequency / 440.0);
                        const closestMidiNote = Math.max(0, Math.min(127, Math.round(midiNoteValue)));
                        const deviationSemitones = midiNoteValue - closestMidiNote;
                        let pitchBendActual = 8192;
                        if (Math.abs(deviationSemitones) > 0.001) {
                            const pitchBendUnits = (deviationSemitones / PITCH_BEND_RANGE_SEMITONES) * 8191;
                            pitchBendActual = Math.max(0, Math.min(16383, Math.round(8192 + pitchBendUnits)));
                        }
                        const pitchBendLSB = pitchBendActual & 0x7F;
                        const pitchBendMSB = (pitchBendActual >> 7) & 0x7F;

                        soundObject.midiNote = closestMidiNote;
                        soundObject.midiChannel = midiChannel;

                        selectedMidiOutput.send([0xE0 | midiChannel, pitchBendLSB, pitchBendMSB]);
                        selectedMidiOutput.send([0x90 | midiChannel, closestMidiNote, 100]);
                    }
                }
            }


            const isSynthDrum = source === 'sequencer_drum_synth';

            if (noteOnDuration !== null) { 
                let stopTime = now + noteOnDuration;
                if (isSelfStopping) {
                    stopTime = now + Math.min(noteOnDuration, soundNaturalDuration);
                    if (mainOsc) mainOsc.stop(stopTime + 0.01);
                    if (modulatorOsc) modulatorOsc.stop(stopTime + 0.01);
                    if (noiseSource) try {noiseSource.stop(stopTime + 0.01);} catch(e){}
                    if (lfo) lfo.stop(stopTime + 0.01);
                    if(soundTypeToUse === 'bell' || soundTypeToUse === 'organ' || soundTypeToUse === 'soft_pad' || soundTypeToUse === 'synth_snare') { 
                        for (const key in activeOscillators) {
                            if (key.startsWith(`${soundId}_aux`) || key.startsWith(`${soundId}_harm`) || key.startsWith(`${soundId}_noise`) || key.startsWith(`${soundId}_body`)) {
                                if(activeOscillators[key] && activeOscillators[key].oscillator) activeOscillators[key].oscillator.stop(stopTime + 0.01);
                            }
                        }
                    }

                } else if (soundTypeToUse === 'pluck_saw' || soundTypeToUse === 'synth' || soundTypeToUse === 'soft_pad' || isSynthDrum) { 
                    const releaseStartTime = now + noteOnDuration;
                    mainGain.gain.cancelScheduledValues(releaseStartTime); 
                    mainGain.gain.setValueAtTime(mainGain.gain.value, releaseStartTime); 
                    let releaseDuration = 0.3;
                    if (soundTypeToUse === 'pluck_saw' && !isSynthDrum) releaseDuration = 0.5; 
                    else if (soundTypeToUse === 'soft_pad') releaseDuration = 0.8;
                    else if (isSynthDrum && (soundTypeToUse === 'pluck_saw' || soundTypeToUse === 'kick_drum' || soundTypeToUse === 'hi_hat_noise' || soundTypeToUse === 'synth_snare')) {
                        releaseDuration = Math.min(soundNaturalDuration || 0.15, noteOnDuration); 
                        stopTime = now + releaseDuration; 
                    }

                    mainGain.gain.exponentialRampToValueAtTime(0.0001, releaseStartTime + releaseDuration); 
                    if (mainOsc) mainOsc.stop(releaseStartTime + releaseDuration + 0.01);
                    if (lfo) lfo.stop(releaseStartTime + releaseDuration + 0.01); 
                     if(soundTypeToUse === 'soft_pad' || soundTypeToUse === 'synth_snare') { 
                        for (const key in activeOscillators) {
                            if (key.startsWith(`${soundId}_aux`) || key.startsWith(`${soundId}_noise`) || key.startsWith(`${soundId}_body`)) {
                                if(activeOscillators[key] && activeOscillators[key].oscillator) activeOscillators[key].oscillator.stop(releaseStartTime + releaseDuration + 0.01); 
                            }
                        }
                    }
                    if(!isSynthDrum || !(soundTypeToUse === 'pluck_saw' || soundTypeToUse === 'kick_drum' || soundTypeToUse === 'hi_hat_noise' || soundTypeToUse === 'synth_snare')) {
                       stopTime = releaseStartTime + releaseDuration; 
                    }
                } else { 
                    let sustainValue = 0.3; 
                    if (soundTypeToUse === 'warm_saw') sustainValue = 0.4;
                    else if (soundTypeToUse === 'lead_square') sustainValue = 0.3;
                    else if (soundTypeToUse === 'organ') sustainValue = 0.2;
                    
                    const currentGain = mainGain.gain.value; 
                    mainGain.gain.cancelScheduledValues(now + noteOnDuration - 0.05); 
                    mainGain.gain.setValueAtTime(currentGain > 0.001 ? currentGain : sustainValue, now + noteOnDuration - 0.05);

                    mainGain.gain.linearRampToValueAtTime(0.0001, stopTime);
                    if (mainOsc) mainOsc.stop(stopTime + 0.01);
                    if (lfo) lfo.stop(stopTime + 0.01); 
                }
                
                setTimeout(() => {
                    for (const key in activeOscillators) {
                        if (key.startsWith(`${soundId}_`)) { 
                             if (activeOscillators[key] && activeOscillators[key].oscillator === (activeOscillators[soundId] ? activeOscillators[soundId].oscillator : null) || key !== soundId) { 
                                delete activeOscillators[key];
                            }
                        }
                    }
                    if (activeOscillators[soundId]) delete activeOscillators[soundId]; 
                    checkWaveformDrawingState();
                }, (stopTime - now + 0.05) * 1000); 

            } else if (isSelfStopping) { 
                 if (mainOsc) mainOsc.stop(now + soundNaturalDuration + 0.01);
                 if (modulatorOsc) modulatorOsc.stop(now + soundNaturalDuration + 0.01);
                 if (noiseSource) try {noiseSource.stop(now + soundNaturalDuration + 0.01);} catch(e){}
                 if (lfo) lfo.stop(now + soundNaturalDuration + 0.01);
                  if(soundTypeToUse === 'bell' || soundTypeToUse === 'organ' || soundTypeToUse === 'soft_pad' || soundTypeToUse === 'synth_snare') {
                        for (const key in activeOscillators) {
                            if (key.startsWith(`${soundId}_aux`) || key.startsWith(`${soundId}_harm`) || key.startsWith(`${soundId}_noise`) || key.startsWith(`${soundId}_body`)) {
                                if(activeOscillators[key] && activeOscillators[key].oscillator) activeOscillators[key].oscillator.stop(now + soundNaturalDuration + 0.01);
                            }
                        }
                    }
                 setTimeout(() => {
                    for (const key in activeOscillators) {
                        if (key.startsWith(`${soundId}_`)) {
                             if (activeOscillators[key] && activeOscillators[key].oscillator === (activeOscillators[soundId] ? activeOscillators[soundId].oscillator : null) || key !== soundId) {
                                delete activeOscillators[key];
                            }
                        }
                    }
                    if (activeOscillators[soundId]) delete activeOscillators[soundId];
                    checkWaveformDrawingState();
                }, (soundNaturalDuration + 0.05) * 1000);
            }
            checkWaveformDrawingState();
        }

        function stopSound(soundId, releaseTime = 0.15) {
            const soundObject = activeOscillators[soundId];
            if (soundObject) {
                if (isMidiOutActive && selectedMidiOutput && soundObject.midiNote !== undefined) {
                    selectedMidiOutput.send([0x80 | soundObject.midiChannel, soundObject.midiNote, 0]); 
                }

                if (soundObject.bufferSourceNode) {
                    try { soundObject.bufferSourceNode.stop(audioContext.currentTime + 0.01); } catch (e) { }
                    delete activeOscillators[soundId];
                    checkWaveformDrawingState();
                    return;
                }

                const { oscillator, gainNode, filterNode, modulatorOsc, modulatorGain, noiseSource, lfo, lfoGain, isSequencerNote, soundTypeUsed } = soundObject;
                const now = audioContext.currentTime;

                for (const key in activeOscillators) {
                    if (key.startsWith(`${soundId}_`) && key !== soundId) { 
                        if (activeOscillators[key] && activeOscillators[key].oscillator) {
                            try { activeOscillators[key].oscillator.stop(now + 0.02); } catch(e) {}
                        }
                        delete activeOscillators[key];
                    }
                }
                
                if (gainNode) {
                    gainNode.gain.cancelScheduledValues(now);
                    gainNode.gain.setValueAtTime(gainNode.gain.value, now);
                }

                let actualReleaseTime = releaseTime;
                 if (isSequencerNote || 
                     (soundTypeUsed === 'pluck_triangle' && !isSequencerNote) || 
                     soundTypeUsed === 'kick_drum' || 
                     soundTypeUsed === 'hi_hat_noise' || 
                     soundTypeUsed === 'bell' || 
                     soundTypeUsed === 'xylophone' ||
                     soundTypeUsed === 'synth_snare'
                    ) { 
                    if (gainNode) gainNode.gain.linearRampToValueAtTime(0.0001, now + 0.01);
                    actualReleaseTime = 0.01; 
                } else if (soundTypeUsed === 'pluck_saw' || soundTypeUsed === 'synth' || soundTypeUsed === 'soft_pad') {
                     if (soundTypeUsed === 'pluck_saw') actualReleaseTime = 0.5;
                     else if (soundTypeUsed === 'synth') actualReleaseTime = 0.3;
                     else if (soundTypeUsed === 'soft_pad') actualReleaseTime = 0.8; 
                     if (gainNode) gainNode.gain.exponentialRampToValueAtTime(0.0001, now + actualReleaseTime);
                } else { 
                    if (gainNode) gainNode.gain.linearRampToValueAtTime(0.0001, now + actualReleaseTime);
                }

                if (oscillator) try { oscillator.stop(now + actualReleaseTime + 0.01); } catch(e){}
                if (modulatorOsc) try { modulatorOsc.stop(now + actualReleaseTime + 0.01); } catch(e){}
                if (noiseSource) try { noiseSource.stop(now + actualReleaseTime + 0.01); } catch(e){} 
                if (lfo) try { lfo.stop(now + actualReleaseTime + 0.01); } catch(e){}
                
                delete activeOscillators[soundId];
                checkWaveformDrawingState();
            }
        }
        
        function checkWaveformDrawingState() {
            const anySoundPlaying = Object.keys(activeOscillators).length > 0;
            if (anySoundPlaying && !waveformAnimationId) { drawWaveform(); } 
            else if (!anySoundPlaying && waveformAnimationId) { cancelAnimationFrame(waveformAnimationId); waveformAnimationId = null;
                setTimeout(() => { if (waveformCtx && Object.keys(activeOscillators).length === 0) { waveformCtx.clearRect(0, 0, waveformCanvas.width, waveformCanvas.height); }}, 200);
            }
        }

        function drawWaveform() {
            if (!analyserNode || !waveformCtx || !waveformDataArray) return;
            waveformAnimationId = requestAnimationFrame(drawWaveform);
            analyserNode.getByteTimeDomainData(waveformDataArray);
            waveformCtx.fillStyle = '#22303f'; waveformCtx.fillRect(0, 0, waveformCanvas.width, waveformCanvas.height);
            waveformCtx.lineWidth = 2; waveformCtx.strokeStyle = '#e67e22'; waveformCtx.beginPath();
            const sliceWidth = waveformCanvas.width * 1.0 / waveformDataArray.length; let x = 0;
            for (let i = 0; i < waveformDataArray.length; i++) { const v = waveformDataArray[i] / 128.0; const y = v * waveformCanvas.height / 2;
                if (i === 0) waveformCtx.moveTo(x, y); else waveformCtx.lineTo(x, y); x += sliceWidth; }
            waveformCtx.lineTo(waveformCanvas.width, waveformCanvas.height / 2); waveformCtx.stroke();
        }

        function clearChordKeyHighlights() {
            highlightedChordKeys.forEach(el => el.classList.remove('chord-playing'));
            highlightedChordKeys = [];
        }

        function stopCurrentArpNoteSoundAndHighlight() {
            if (currentArpSoundId) stopSound(currentArpSoundId, 0.01);
            if (currentArpPlayingKeyElement) currentArpPlayingKeyElement.classList.remove('chord-playing');
            currentArpSoundId = null;
            currentArpPlayingKeyElement = null;
        }

        function stopArpLoop() {
            if (arpLoopIntervalId) clearInterval(arpLoopIntervalId);
            arpLoopIntervalId = null;
            stopCurrentArpNoteSoundAndHighlight();
            currentArpChordType = null;
        }
        
        function playNextArpNote() {
            if (!isArpeggioActive || !currentArpChordType || !chordDefinitions[currentArpChordType]) {
                stopArpLoop();
                return;
            }
        
            const chordDef = chordDefinitions[currentArpChordType];
            const validNotes = chordDef.currentKeyIndices.filter(ki => {
                if (ki === null) return false;
                const keyIndex = (typeof ki === 'object') ? ki.keyIndex : ki;
                return keysData[keyIndex] !== null; // Check that the key slot is not empty
            });
        
            if (validNotes.length === 0) {
                stopArpLoop();
                return;
            }
        
            currentArpNoteIndex = currentArpNoteIndex % validNotes.length;
            const keyInfo = validNotes[currentArpNoteIndex];
        
            let keyIndex, octaveMod = 0;
            if (typeof keyInfo === 'number') {
                keyIndex = keyInfo;
            } else { 
                keyIndex = keyInfo.keyIndex;
                octaveMod = keyInfo.octaveMod || 0;
            }
        
            if (keyIndex === null || keyIndex === undefined || keyIndex < 0 || keyIndex >= NUM_PIANO_KEYS || !keysData[keyIndex]) {
                currentArpNoteIndex++;
                return;
            }
        
            const freqObject = getFrequencyForKey(keyIndex, octaveMod);
            const arpStepDurationMs = (60 / currentSeqTempoBPM) * 1000 / 4;
        
            if (freqObject !== null) {
                stopCurrentArpNoteSoundAndHighlight(); 
        
                currentArpSoundId = `arp_${currentArpChordType}_note${currentArpNoteIndex}`;
                playSound(freqObject, currentArpSoundId, 'key', (arpStepDurationMs / 1000) * 0.95);
        
                currentArpPlayingKeyElement = document.querySelector(`.piano-key[data-key-index="${keyIndex}"]`);
                if (currentArpPlayingKeyElement) {
                    currentArpPlayingKeyElement.classList.add('chord-playing');
                }
            }
            currentArpNoteIndex++;
        }

        async function playChord(chordType) {
            await initAudioContext();
            const chordDef = chordDefinitions[chordType];
            if (!chordDef) return;

            clearChordKeyHighlights(); 
            stopActiveChordSounds(); 

            if (isArpeggioActive) {
                stopArpLoop(); 
                currentArpChordType = chordType;
                currentArpNoteIndex = 0;
                const arpStepDurationMs = (60 / currentSeqTempoBPM) * 1000 / 4;
                playNextArpNote(); 
                arpLoopIntervalId = setInterval(playNextArpNote, arpStepDurationMs);
            } else {
                stopArpLoop(); 
                const soundIds = [];
                for (let i = 0; i < chordDef.currentKeyIndices.length; i++) {
                    const keyInfo = chordDef.currentKeyIndices[i];
                    if (keyInfo === null) continue; 

                    let keyIndex, octaveMod = 0;
                    if (typeof keyInfo === 'number') {
                        keyIndex = keyInfo;
                    } else { 
                        keyIndex = keyInfo.keyIndex;
                        octaveMod = keyInfo.octaveMod || 0;
                    }
                    if (keyIndex === null || keyIndex === undefined || keyIndex < 0 || keyIndex >= NUM_PIANO_KEYS || !keysData[keyIndex]) continue;

                    const freqObject = getFrequencyForKey(keyIndex, octaveMod);
                    if (freqObject !== null) {
                        const soundId = `chord_${chordType}_note${i}`;
                        playSound(freqObject, soundId, 'key');
                        activeChordSounds.push(soundId);
                        
                        const keyElement = document.querySelector(`.piano-key[data-key-index="${keyIndex}"]`);
                        if (keyElement) {
                            keyElement.classList.add('chord-playing');
                            highlightedChordKeys.push(keyElement);
                        }
                    }
                }
            }
        }

        function stopActiveChordSounds() { 
            activeChordSounds.forEach(id => stopSound(id)); 
            activeChordSounds = []; 
            clearChordKeyHighlights(); 
        }

        function createChordKeySelectors(chordType) {
            const chordDef = chordDefinitions[chordType];
            if (!chordDef) return;

            const selectorsContainer = document.getElementById(`chord-selectors-${chordType}`);
            if (!selectorsContainer) return;
            selectorsContainer.innerHTML = '';

            for (let noteIndex = 0; noteIndex < chordDef.numNotes; noteIndex++) {
                const controlGroupDiv = document.createElement('div');
                controlGroupDiv.classList.add('control-group');

                const labelEl = document.createElement('label');
                labelEl.textContent = `${chordDef.labels[noteIndex] || `Note ${noteIndex + 1}`}:`;
                labelEl.htmlFor = `chord-${chordType}-key${noteIndex}-select`;
                
                const selectEl = document.createElement('select');
                selectEl.id = `chord-${chordType}-key${noteIndex}-select`;
                selectEl.dataset.chordType = chordType;
                selectEl.dataset.noteIndex = noteIndex;

                const noneOption = document.createElement('option');
                noneOption.value = "-1"; 
                noneOption.textContent = "None";
                selectEl.appendChild(noneOption);

                const hasValidKeys = keysData.some(k => k !== null);

                if (!hasValidKeys) {
                    selectEl.disabled = true;
                } else {
                    for (let i = 0; i < NUM_PIANO_KEYS; i++) {
                        if (!keysData[i]) continue; // Skip null keys
                        const option = document.createElement('option');
                        option.value = i;
                        const effectiveInterval = getEffectiveIntervalString(i);
                        option.textContent = `Key ${i + 1} (${effectiveInterval})`;
                        selectEl.appendChild(option);
                    }
                    selectEl.disabled = false;
                }
                
                let currentKeyForNote;
                const keyDef = chordDef.currentKeyIndices[noteIndex];

                if (keyDef === null) { 
                    currentKeyForNote = -1;
                } else if (typeof keyDef === 'object') {
                    currentKeyForNote = keyDef.keyIndex;
                } else {
                    currentKeyForNote = keyDef;
                }
                
                if (!hasValidKeys) {
                    selectEl.value = "-1"; 
                } else if (currentKeyForNote === -1 || !keysData[currentKeyForNote]) {
                    selectEl.value = "-1";
                } else {
                     selectEl.value = currentKeyForNote;
                }

                selectEl.addEventListener('change', (event) => {
                    const selectedValue = parseInt(event.target.value);
                    const cType = event.target.dataset.chordType;
                    const nIndex = parseInt(event.target.dataset.noteIndex);

                    if (selectedValue === -1) {
                        chordDefinitions[cType].currentKeyIndices[nIndex] = null; 
                    } else {
                        let currentNoteDefinition = chordDefinitions[cType].currentKeyIndices[nIndex];
                        if (typeof currentNoteDefinition === 'object' && currentNoteDefinition !== null) {
                            currentNoteDefinition.keyIndex = selectedValue;
                        } else { 
                            chordDefinitions[cType].currentKeyIndices[nIndex] = selectedValue;
                        }
                    }
                });
                controlGroupDiv.appendChild(labelEl);
                controlGroupDiv.appendChild(selectEl);
                selectorsContainer.appendChild(controlGroupDiv);
            }
        }
        
        function buildChordGroupUI(chordId) {
            const chordDef = chordDefinitions[chordId];
            if (!chordDef) return;
        
            const groupDiv = document.createElement('div');
            groupDiv.classList.add('chord-definition-group');
            groupDiv.id = `chord-group-${chordId}`;
        
            const button = document.createElement('button');
            button.classList.add('chord-button');
            button.dataset.type = chordId;
            button.textContent = chordDef.name;
        
            button.addEventListener('mousedown', () => { playChord(chordId); button.classList.add('playing'); });
            button.addEventListener('mouseup', () => { 
                if (isArpeggioActive && currentArpChordType === chordId) {
                    stopArpLoop();
                } else if (!isArpeggioActive) {
                    stopActiveChordSounds();
                }
                button.classList.remove('playing');
            });
            button.addEventListener('mouseleave', () => { 
                if (button.classList.contains('playing')) {
                    if (isArpeggioActive && currentArpChordType === chordId) {
                        // Don't stop the arp on mouseleave
                    } else if (!isArpeggioActive) {
                        stopActiveChordSounds();
                        button.classList.remove('playing');
                    }
                }
            });
            button.addEventListener('touchstart', (e) => { e.preventDefault(); playChord(chordId); button.classList.add('playing'); });
            button.addEventListener('touchend', (e) => { 
                e.preventDefault(); 
                if (isArpeggioActive && currentArpChordType === chordId) {
                    stopArpLoop();
                } else if (!isArpeggioActive) {
                    stopActiveChordSounds();
                }
                button.classList.remove('playing');
            });
        
            groupDiv.appendChild(button);

            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.value = chordDef.name;
            nameInput.dataset.chordType = chordId;
            nameInput.style.width = '90%';
            nameInput.style.textAlign = 'center';
            nameInput.style.backgroundColor = '#566573';
            nameInput.style.color = '#ecf0f1';
            nameInput.style.border = '1px solid #4a6278';
            nameInput.style.borderRadius = '4px';
            nameInput.style.padding = '4px';
            nameInput.style.fontSize = '0.7em';
            nameInput.style.marginTop = '4px';
            nameInput.placeholder = "Chord Name";

            nameInput.addEventListener('input', (event) => {
                const cType = event.target.dataset.chordType;
                const newName = event.target.value;
                chordDefinitions[cType].name = newName;
                const chordButton = groupDiv.querySelector(`.chord-button[data-type="${cType}"]`);
                if(chordButton) {
                    chordButton.textContent = newName;
                }
            });
            groupDiv.appendChild(nameInput);

            const numNotesControlDiv = document.createElement('div');
            numNotesControlDiv.classList.add('chord-num-notes-control');
            
            const numNotesLabel = document.createElement('label');
            numNotesLabel.textContent = "Notes:";
            numNotesLabel.htmlFor = `chord-${chordId}-num-notes-input`;
            numNotesControlDiv.appendChild(numNotesLabel);

            const numNotesInput = document.createElement('input');
            numNotesInput.type = 'number';
            numNotesInput.id = `chord-${chordId}-num-notes-input`;
            numNotesInput.value = chordDef.numNotes;
            numNotesInput.min = 1;
            numNotesInput.max = 8; 
            numNotesInput.dataset.chordType = chordId;

            numNotesInput.addEventListener('change', (event) => {
                const cType = event.target.dataset.chordType;
                const newNumNotes = parseInt(event.target.value);
                if (isNaN(newNumNotes) || newNumNotes < 1 || newNumNotes > 8) {
                    event.target.value = chordDefinitions[cType].numNotes; 
                    return;
                }
                chordDefinitions[cType].numNotes = newNumNotes;
                const oldIndices = chordDefinitions[cType].currentKeyIndices;
                const newIndices = Array(newNumNotes);
                for (let i = 0; i < newNumNotes; i++) {
                    if (i < oldIndices.length) {
                        newIndices[i] = oldIndices[i];
                    } else {
                        newIndices[i] = null; 
                    }
                }
                chordDefinitions[cType].currentKeyIndices = newIndices;
                chordDefinitions[cType].labels = Array(newNumNotes).fill(null).map((_, i) => `Note ${i + 1}`);
                
                createChordKeySelectors(cType); 
            });
            numNotesControlDiv.appendChild(numNotesInput);
            groupDiv.appendChild(numNotesControlDiv);
        
            const selectorsDiv = document.createElement('div');
            selectorsDiv.classList.add('chord-key-selectors');
            selectorsDiv.id = `chord-selectors-${chordId}`;
            groupDiv.appendChild(selectorsDiv);
        
            chordButtonsRowDiv.appendChild(groupDiv);
        }

        function initChordSystem() {
            NUM_CHORDS = parseInt(numChordsInput.value);
            chordDefinitions = {}; 
            if (chordButtonsRowDiv) chordButtonsRowDiv.innerHTML = ''; 

            for (let i = 0; i < NUM_CHORDS; i++) {
                const chordId = `cho${i + 1}`;
                const defaultNumNotes = 4;
                const defaultKeyIndices = Array(defaultNumNotes).fill(null).map((_, idx) => {
                    const defaultProgression = [0, 4, 7, 10];
                    let potentialIndex = defaultProgression[idx % defaultProgression.length];
                    // Find the first valid key at or after the potential index
                    for (let k = potentialIndex; k < keysData.length; k++) {
                        if (keysData[k]) return k;
                    }
                    // If not found, wrap around and search from the beginning
                    for (let k = 0; k < potentialIndex; k++) {
                        if (keysData[k]) return k;
                    }
                    return null; // No valid keys exist
                });

                chordDefinitions[chordId] = {
                    name: `Chord ${i + 1}`,
                    numNotes: defaultNumNotes,
                    currentKeyIndices: defaultKeyIndices,
                    labels: Array(defaultNumNotes).fill(null).map((_, j) => `Note ${j + 1}`)
                };
                buildChordGroupUI(chordId); 
                createChordKeySelectors(chordId); 
            }
        }

        function setupChordControls() {
            numChordsInput = document.getElementById('num-chords-input');
            applyNumChordsBtn = document.getElementById('apply-num-chords-btn');
            chordButtonsRowDiv = document.getElementById('chord-buttons-row');
            arpToggleBtn = document.getElementById('arp-toggle-btn');

            if (applyNumChordsBtn) applyNumChordsBtn.addEventListener('click', initChordSystem);
            
            arpToggleBtn.addEventListener('click', () => { 
                isArpeggioActive = !isArpeggioActive; 
                arpToggleBtn.textContent = `Arp: ${isArpeggioActive ? 'On' : 'Off'}`; 
                arpToggleBtn.classList.toggle('active', isArpeggioActive);
                if (!isArpeggioActive) { 
                    stopArpLoop(); 
                    document.querySelectorAll('.chord-button.playing').forEach(b => b.classList.remove('playing'));
                }
            });
            
            initChordSystem(); 
        }

        function createSequencerGrid() {
            sequencerGridDiv = document.getElementById('sequencer-grid'); 
            if (!sequencerGridDiv) return;
            sequencerGridDiv.innerHTML = ''; 
        
            for (let r_drum = 0; r_drum < NUM_DRUM_ROWS; r_drum++) {
                const actualRowIndex = r_drum; 
                const drumName = DRUM_ROW_NAMES[r_drum];
        
                const rowWrapperDiv = document.createElement('div'); 
                rowWrapperDiv.classList.add('sequencer-row-wrapper');
                
                const drumControlCell = document.createElement('div');
                drumControlCell.classList.add('seq-drum-control-cell');

                const drumLabel = document.createElement('div');
                drumLabel.classList.add('seq-row-label');
                drumLabel.textContent = drumName;
                drumLabel.title = `Click to play ${drumName}`;
                drumLabel.addEventListener('click', async () => {
                    await initAudioContext();
                    const drumSoundId = `manual_play_${drumName}_${Date.now()}`;
                    if (drumSamples[drumName]) {
                        const sourceNode = audioContext.createBufferSource();
                        sourceNode.buffer = drumSamples[drumName];
                        sourceNode.connect(keysMasterGain);
                        sourceNode.start(audioContext.currentTime);
                        activeOscillators[drumSoundId] = { bufferSourceNode: sourceNode, source: 'key' };
                        sourceNode.onended = () => { delete activeOscillators[drumSoundId]; checkWaveformDrawingState(); };
                    } else {
                        let frequencyForDrumFallback = 100;
                        if (drumName === 'Kick') frequencyForDrumFallback = 60;
                        else if (drumName === 'Snare') frequencyForDrumFallback = 200;
                        else if (drumName === 'Hi-Hat') frequencyForDrumFallback = 8000;
                        playSound({ finalFreq: frequencyForDrumFallback, baseFreq: frequencyForDrumFallback }, drumSoundId, 'key', 0.2, DRUM_FALLBACK_SYNTHS[r_drum]);
                    }
                });

                drumControlCell.appendChild(drumLabel);

             //   const loadSampleBtn = document.createElement('button');
             //   loadSampleBtn.textContent = 'Load .wav';
             //   loadSampleBtn.classList.add('control-button');
             //   loadSampleBtn.style.fontSize = '0.65em';
             //   loadSampleBtn.style.padding = '2px 4px';
             //   loadSampleBtn.dataset.drumIndex = r_drum; 

             //   const fileInput = document.createElement('input');
             //   fileInput.type = 'file';
             //   fileInput.accept = '.wav,audio/wav';
             //   fileInput.style.display = 'none';
             //   fileInput.dataset.drumIndex = r_drum;

             //   loadSampleBtn.addEventListener('click', () => {
             //       fileInput.click();
             //   });

             //   fileInput.addEventListener('change', (event) => {
             //       loadCustomDrumSample(event, r_drum);
             //   });

             //   drumControlCell.appendChild(loadSampleBtn);
             //   drumControlCell.appendChild(fileInput);
                
                rowWrapperDiv.appendChild(drumControlCell);
        
                const rowDiv = document.createElement('div'); 
                rowDiv.classList.add('sequencer-row'); 
                rowDiv.dataset.row = actualRowIndex;
        
                for (let s = 0; s < NUM_SEQ_STEPS; s++) { 
                    const stepDiv = document.createElement('div'); 
                    stepDiv.classList.add('sequencer-step');
                    stepDiv.classList.add(`drum-${drumName.toLowerCase().replace(/\s+/g,'-')}`); 
                    stepDiv.dataset.row = actualRowIndex; 
                    stepDiv.dataset.step = s; 
                    stepDiv.addEventListener('click', () => toggleSequencerStep(actualRowIndex, s));
                    if (sequencerData[actualRowIndex] && sequencerData[actualRowIndex][s]) {
                        stepDiv.classList.add('active');
                    }
                    rowDiv.appendChild(stepDiv); 
                }
                rowWrapperDiv.appendChild(rowDiv); 
                sequencerGridDiv.appendChild(rowWrapperDiv);
            }
        
            for (let r_melodic = 0; r_melodic < NUM_SEQ_MELODIC_ROWS; r_melodic++) {
                const actualRowIndex = NUM_DRUM_ROWS + r_melodic; 
        
                const rowWrapperDiv = document.createElement('div'); 
                rowWrapperDiv.classList.add('sequencer-row-wrapper');
                
                const keySelect = document.createElement('select'); 
                keySelect.classList.add('seq-row-key-select'); 
                keySelect.dataset.rowIndex = r_melodic; 
                
                let hasAnyKeys = false;
                for (let k = 0; k < NUM_PIANO_KEYS; k++) { 
                    if (!keysData[k]) continue;
                    hasAnyKeys = true;
                    const option = document.createElement('option'); option.value = k;
                    const effectiveIntervalForSeqDisp = getEffectiveIntervalString(k);
                    option.textContent = `Key ${k+1} (${effectiveIntervalForSeqDisp})`; 
                    keySelect.appendChild(option); 
                }
                
                if (!hasAnyKeys) {
                    const option = document.createElement('option');
                    option.textContent = "N/A"; option.value = "";
                    keySelect.appendChild(option);
                    keySelect.disabled = true;
                    SEQ_ROW_KEY_INDICES[r_melodic] = undefined;
                } else {
                    keySelect.disabled = false;
                    const currentAssignedKey = SEQ_ROW_KEY_INDICES[r_melodic];
                    if (currentAssignedKey !== undefined && keysData[currentAssignedKey]) {
                        keySelect.value = currentAssignedKey;
                    } else {
                        keySelect.selectedIndex = 0;
                        SEQ_ROW_KEY_INDICES[r_melodic] = parseInt(keySelect.value, 10);
                    }
                }
        
                keySelect.addEventListener('change', (e) => { 
                    const changedMelodicRowIndex = parseInt(e.target.dataset.rowIndex);
                    SEQ_ROW_KEY_INDICES[changedMelodicRowIndex] = parseInt(e.target.value); 
                });
                rowWrapperDiv.appendChild(keySelect);
        
                const rowDiv = document.createElement('div'); 
                rowDiv.classList.add('sequencer-row'); 
                rowDiv.dataset.row = actualRowIndex;
                for (let s = 0; s < NUM_SEQ_STEPS; s++) { 
                    const stepDiv = document.createElement('div'); 
                    stepDiv.classList.add('sequencer-step'); 
                    stepDiv.dataset.row = actualRowIndex; 
                    stepDiv.dataset.step = s; 
                    stepDiv.addEventListener('click', () => toggleSequencerStep(actualRowIndex, s));
                    if (sequencerData[actualRowIndex] && sequencerData[actualRowIndex][s]) {
                        stepDiv.classList.add('active');
                    } 
                    rowDiv.appendChild(stepDiv); 
                }
                rowWrapperDiv.appendChild(rowDiv); 
                sequencerGridDiv.appendChild(rowWrapperDiv);
            }
            updateKeyDisplays(); 
        }

        async function toggleSequencerStep(row, step) { 
            await initAudioContext(); 
            sequencerData[row][step] = !sequencerData[row][step];
            const stepDiv = sequencerGridDiv.querySelector(`.sequencer-step[data-row="${row}"][data-step="${step}"]`);
            if (stepDiv) stepDiv.classList.toggle('active', sequencerData[row][step]);
        }
        
        function updateSequencerTempo(newTempo) { currentSeqTempoBPM = Math.max(20, Math.min(300, parseInt(newTempo, 10)));
            if(seqTempoDisplay) seqTempoDisplay.textContent = `${currentSeqTempoBPM} BPM`; 
            if (isSequencerPlaying) { stopSequencer(); startSequencer(); }
            if (isArpeggioActive && arpLoopIntervalId) { 
                const tempChordType = currentArpChordType;
                stopArpLoop();
                const arpButton = document.querySelector(`.chord-button[data-type="${tempChordType}"]`);
                if(arpButton) {
                    playChord(tempChordType); 
                }
            }
        }

        async function handleTapTempo() { 
            await initAudioContext(); 
            const now = performance.now();
            if (tapTempoCount === 0 || (now - lastTapTime > 2000)) { tapTempoCount = 0; lastTapTime = now; tapTempoCount++; return; }
            const diff = now - lastTapTime; lastTapTime = now; const currentTapBPM = 60000 / diff;
            if (currentTapBPM > 30 && currentTapBPM < 300) { updateSequencerTempo(Math.round(currentTapBPM));
                 if (seqTempoSlider) seqTempoSlider.value = currentSeqTempoBPM; if (seqTempoInput) seqTempoInput.value = currentSeqTempoBPM; }
            tapTempoCount++;
        }

        function setupGlobalAudioControls() {
            keysVolumeSlider = document.getElementById('keys-volume-slider'); sequencerVolumeSlider = document.getElementById('sequencer-volume-slider');
            soundTypeKeysSelect = document.getElementById('sound-type-keys-select'); soundTypeSeqSelect = document.getElementById('sound-type-seq-select');
            
            exportSoundDefsBtn = document.getElementById('export-sound-definitions-btn');
            importSoundDefsInput = document.getElementById('import-sound-definitions-input');
            importSoundDefsBtn = document.getElementById('import-sound-definitions-btn');

            if(keysVolumeSlider) { keysVolumeSlider.addEventListener('input', (e) => { if (keysMasterGain) keysMasterGain.gain.value = parseFloat(e.target.value); });
                if(keysMasterGain) keysMasterGain.gain.value = parseFloat(keysVolumeSlider.value); }
            if(sequencerVolumeSlider) { sequencerVolumeSlider.addEventListener('input', (e) => { if (sequencerMasterGain) sequencerMasterGain.gain.value = parseFloat(e.target.value); });
                if(sequencerMasterGain) sequencerMasterGain.gain.value = parseFloat(sequencerVolumeSlider.value); }
            
            if(soundTypeKeysSelect) { soundTypeKeysSelect.addEventListener('change', (e) => currentSoundTypeKeys = e.target.value ); }
            if(soundTypeSeqSelect) { soundTypeSeqSelect.addEventListener('change', (e) => currentSoundTypeSeq = e.target.value ); }
            
            if(exportSoundDefsBtn) exportSoundDefsBtn.addEventListener('click', exportSoundDefinitions);
            if(importSoundDefsBtn) importSoundDefsBtn.addEventListener('click', () => importSoundDefsInput.click());
            if(importSoundDefsInput) importSoundDefsInput.addEventListener('change', loadSoundDefinitions);

            const initialSoundNames = extractSoundNames(soundDefinitionFunctionBody);
            updateSoundSelectors(initialSoundNames);
            currentSoundTypeKeys = soundTypeKeysSelect.value; 
            currentSoundTypeSeq = soundTypeSeqSelect.value;   
        }

        function extractSoundNames(codeString) {
            const soundNames = [];
            const regex = /case\s+['"]([^'"]+)['"]\s*:/g;
            let match;
            while ((match = regex.exec(codeString)) !== null) {
                soundNames.push(match[1]);
            }
            return [...new Set(soundNames)]; 
        }

        function updateSoundSelectors(newSoundNames) {
            const selectors = [soundTypeKeysSelect, soundTypeSeqSelect];
            const currentSelections = [currentSoundTypeKeys, currentSoundTypeSeq]; 

            selectors.forEach((select, index) => {
                if (!select) return;
                const previouslySelectedValue = currentSelections[index];
                select.innerHTML = ''; 

                if (newSoundNames.length === 0) {
                     const option = document.createElement('option');
                     option.value = "";
                     option.textContent = "No Sounds Defined";
                     select.appendChild(option);
                } else {
                    newSoundNames.forEach(name => {
                        const option = document.createElement('option');
                        option.value = name;
                        option.textContent = name.charAt(0).toUpperCase() + name.slice(1).replace(/_/g, ' ');
                        select.appendChild(option);
                    });
                }
                
                if (newSoundNames.includes(previouslySelectedValue)) {
                    select.value = previouslySelectedValue;
                } else if (newSoundNames.length > 0) {
                    select.value = newSoundNames[0];
                } else {
                    select.value = ""; 
                }

                if (index === 0) currentSoundTypeKeys = select.value;
                if (index === 1) currentSoundTypeSeq = select.value;
            });
        }

        function exportSoundDefinitions() {
            const fileContent = `// Custom Sound Definitions for Tunable Keys
// To use, import this file using the "Import Sound Code" button.
// You can add new sounds by creating a new 'case "your_sound_name":' block.
// The function must return an object with at least mainOsc and mainGain.
// --- START OF EDITABLE CODE (Function Body) ---

${soundDefinitionFunctionBody}

// --- END OF EDITABLE CODE (Function Body) ---
`;
            const blob = new Blob([fileContent], { type: "text/plain" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = "custom_sound_definitions.js";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            alert("Sound definition code exported as custom_sound_definitions.js!");
        }

        function loadSoundDefinitions(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    let newFunctionBodyFromFile = e.target.result;
                    const startMarker = "// --- START OF EDITABLE CODE (Function Body) ---";
                    const endMarker = "// --- END OF EDITABLE CODE (Function Body) ---";
                    const startIndex = newFunctionBodyFromFile.indexOf(startMarker);
                    const endIndex = newFunctionBodyFromFile.indexOf(endMarker);
                    let extractedBody;
                    if (startIndex !== -1 && endIndex !== -1 && endIndex > startIndex) {
                        extractedBody = newFunctionBodyFromFile.substring(startIndex + startMarker.length, endIndex).trim();
                    } else {
                        extractedBody = newFunctionBodyFromFile.trim();
                        alert("Warning: File structure markers not found. Attempting to load entire file content as sound definitions.");
                    }
                    new Function('soundType', 'frequency', 'now', 'audioContext', 'masterGainNode', 'soundId', 'activeOscillators', extractedBody); 
                    soundDefinitionFunctionBody = extractedBody;
                    currentSoundGenerator = new Function('soundType', 'frequency', 'now', 'audioContext', 'masterGainNode', 'soundId', 'activeOscillators', soundDefinitionFunctionBody);
                    const newSoundNames = extractSoundNames(soundDefinitionFunctionBody);
                    if (newSoundNames.length === 0) {
                        alert("Warning: No sound definitions (e.g., 'case \"sound_name\":') found in the imported file's active code block.");
                    }
                    updateSoundSelectors(newSoundNames);
                    alert("Sound definitions loaded successfully!");
                } catch (error) {
                    console.error("Error loading sound definitions:", error);
                    alert("Failed to load sound definitions file. Details: " + error.message);
                }
            };
            reader.readAsText(file);
            if (event.target) event.target.value = null; 
        }

        function handleApplySeqRows() { 
            const newNumMelodicRows = parseInt(numSeqRowsInput.value, 10);
            if (isNaN(newNumMelodicRows) || newNumMelodicRows < 0 || newNumMelodicRows > 13) { 
                alert("Number of melodic rows must be between 0 and 13.");
                numSeqRowsInput.value = NUM_SEQ_MELODIC_ROWS;
                return;
            }
            NUM_SEQ_MELODIC_ROWS = newNumMelodicRows;
            const totalRows = NUM_DRUM_ROWS + NUM_SEQ_MELODIC_ROWS;
        
            const oldSequencerData = sequencerData;
            sequencerData = Array(totalRows).fill(null).map((_, r) => {
                if (r < oldSequencerData.length && oldSequencerData[r]) {
                    const oldRow = oldSequencerData[r];
                    const newRow = Array(NUM_SEQ_STEPS).fill(false);
                    for (let s = 0; s < Math.min(oldRow.length, NUM_SEQ_STEPS); s++) {
                        newRow[s] = oldRow[s] || false;
                    }
                    return newRow;
                }
                return Array(NUM_SEQ_STEPS).fill(false);
            });
        
            const oldKeyIndices = [...SEQ_ROW_KEY_INDICES];
            SEQ_ROW_KEY_INDICES = Array(NUM_SEQ_MELODIC_ROWS);
            for (let i = 0; i < NUM_SEQ_MELODIC_ROWS; i++) {
                if (i < oldKeyIndices.length && oldKeyIndices[i] !== undefined && keysData[oldKeyIndices[i]]) {
                    SEQ_ROW_KEY_INDICES[i] = oldKeyIndices[i];
                } else {
                    // Find the first available key
                    const firstValidKeyIndex = keysData.findIndex(k => k !== null);
                    SEQ_ROW_KEY_INDICES[i] = (firstValidKeyIndex !== -1) ? firstValidKeyIndex : undefined;
                }
            }
            if (isSequencerPlaying) stopSequencer();
            createSequencerGrid();
        }

        function handleApplySeqSteps() { 
            const newNumSteps = parseInt(numSeqStepsInput.value, 10);
            if (isNaN(newNumSteps) || newNumSteps < 4 || newNumSteps > 64) { 
                alert("Number of steps must be between 4 and 64."); 
                numSeqStepsInput.value = NUM_SEQ_STEPS; return; 
            }
            const oldNumSteps = NUM_SEQ_STEPS; 
            NUM_SEQ_STEPS = newNumSteps;
            const totalRows = NUM_DRUM_ROWS + NUM_SEQ_MELODIC_ROWS;

            const newSequencerData = Array(totalRows).fill(null).map((_, r) => { 
                const oldRow = sequencerData[r] || []; 
                const newRow = Array(NUM_SEQ_STEPS).fill(false);
                for (let s = 0; s < Math.min(oldNumSteps, NUM_SEQ_STEPS); s++) { 
                    newRow[s] = oldRow[s] || false; 
                } 
                return newRow; 
            });
            sequencerData = newSequencerData; 
            if (isSequencerPlaying) stopSequencer(); 
            currentSeqStep = 0; 
            createSequencerGrid(); 
        }

        function setupSequencerControls() {
            seqPlayStopBtn = document.getElementById('seq-play-stop-btn'); seqTempoSlider = document.getElementById('seq-tempo-slider');
            seqTempoDisplay = document.getElementById('seq-tempo-display'); seqTempoInput = document.getElementById('seq-tempo-input');
            tapTempoBtn = document.getElementById('tap-tempo-btn'); numSeqStepsInput = document.getElementById('num-seq-steps-input');
            applySeqStepsBtn = document.getElementById('apply-seq-steps-btn');
            numSeqRowsInput = document.getElementById('num-seq-rows-input'); 
            applySeqRowsBtn = document.getElementById('apply-seq-rows-btn'); 

            if(seqPlayStopBtn) seqPlayStopBtn.addEventListener('click', async () => { await initAudioContext(); if (isSequencerPlaying) stopSequencer(); else startSequencer(); });
            if(seqTempoSlider) seqTempoSlider.addEventListener('input', (e) => { updateSequencerTempo(e.target.value); if(seqTempoInput) seqTempoInput.value = e.target.value; });
            if(seqTempoInput) seqTempoInput.addEventListener('change', (e) => { updateSequencerTempo(e.target.value); if(seqTempoSlider) seqTempoSlider.value = e.target.value;});
            if(tapTempoBtn) tapTempoBtn.addEventListener('click', handleTapTempo); 
            if(applySeqStepsBtn) applySeqStepsBtn.addEventListener('click', handleApplySeqSteps);
            if(applySeqRowsBtn) applySeqRowsBtn.addEventListener('click', handleApplySeqRows); 

            document.getElementById('save-sequence-btn')?.addEventListener('click', saveSequence);
            const loadSeqInput = document.getElementById('load-sequence-input');
            document.getElementById('load-sequence-btn')?.addEventListener('click', () => loadSeqInput?.click()); 
            loadSeqInput?.addEventListener('change', loadSequence);
            document.getElementById('export-midi-btn')?.addEventListener('click', exportMIDI);
            
            if (numSeqStepsInput) numSeqStepsInput.value = NUM_SEQ_STEPS; 
            if (numSeqRowsInput) numSeqRowsInput.value = NUM_SEQ_MELODIC_ROWS; 
            updateSequencerTempo(currentSeqTempoBPM); 
            if (seqTempoSlider) seqTempoSlider.value = currentSeqTempoBPM; if (seqTempoInput) seqTempoInput.value = currentSeqTempoBPM;
        }

        async function startSequencer() { 
            await initAudioContext(); 
            if (isSequencerPlaying) return; 
            isSequencerPlaying = true;
            if(seqPlayStopBtn) { seqPlayStopBtn.textContent = "Stop"; seqPlayStopBtn.classList.add('active'); }
            currentSeqStep = -1; 
            const stepDurationMs = (60 / currentSeqTempoBPM) * 1000 / 4; 
            
            function tick() { 
                if(!isSequencerPlaying) return; 
                const prevStepDivs = sequencerGridDiv?.querySelectorAll(`.sequencer-step.current`);
                prevStepDivs?.forEach(div => div.classList.remove('current')); 
                currentSeqStep = (currentSeqStep + 1) % NUM_SEQ_STEPS;
                const currentStepDivs = sequencerGridDiv?.querySelectorAll(`.sequencer-step[data-step="${currentSeqStep}"]`);
                currentStepDivs?.forEach(div => div.classList.add('current'));
                
                const totalRows = NUM_DRUM_ROWS + NUM_SEQ_MELODIC_ROWS;
                for (let dataRowIndex = 0; dataRowIndex < totalRows; dataRowIndex++) { 
                    if (sequencerData[dataRowIndex] && sequencerData[dataRowIndex][currentSeqStep]) {
                        if (dataRowIndex < NUM_DRUM_ROWS) { 
                            const drumIndex = dataRowIndex;
                            const drumName = DRUM_ROW_NAMES[drumIndex];
                            const drumSoundId = `seq_drum_${drumName}_s${currentSeqStep}`;
                            const noteDurSec = (stepDurationMs / 1000) * 0.95;

                            if (drumSamples[drumName]) { 
                                const sourceNode = audioContext.createBufferSource();
                                sourceNode.buffer = drumSamples[drumName];
                                sourceNode.connect(sequencerMasterGain);
                                sourceNode.start(audioContext.currentTime);
                                activeOscillators[drumSoundId] = { bufferSourceNode: sourceNode, source: 'sequencer_drum_sample' };
                                sourceNode.onended = () => { delete activeOscillators[drumSoundId]; checkWaveformDrawingState(); };
                            } else { 
                                let frequencyForDrumFallback = 100; 
                                if (drumName === 'Kick') frequencyForDrumFallback = 60;
                                else if (drumName === 'Snare') frequencyForDrumFallback = 200;
                                else if (drumName === 'Hi-Hat') frequencyForDrumFallback = 8000; 
                                playSound({ finalFreq: frequencyForDrumFallback, baseFreq: frequencyForDrumFallback }, drumSoundId, 'sequencer_drum_synth', noteDurSec, DRUM_FALLBACK_SYNTHS[drumIndex]);
                            }
                        } else { 
                            const melodicRowIndex = dataRowIndex - NUM_DRUM_ROWS;
                            const keyIndexToPlay = SEQ_ROW_KEY_INDICES[melodicRowIndex]; 
                            if (keyIndexToPlay === undefined || keyIndexToPlay === null || keyIndexToPlay < 0 || keyIndexToPlay >= NUM_PIANO_KEYS || !keysData[keyIndexToPlay]) continue; 
                            const freqObject = getFrequencyForKey(keyIndexToPlay); 
                            if (freqObject !== null) { 
                                playSound(freqObject, `seq_r${dataRowIndex}_s${currentSeqStep}`, 'sequencer', (stepDurationMs / 1000) * 0.95); 
                            }
                        }
                    }
                }
                if (isSequencerPlaying) { seqIntervalId = setTimeout(tick, stepDurationMs); }
            }
            tick(); 
        }

        function stopSequencer() { if (!isSequencerPlaying) return; isSequencerPlaying = false; clearTimeout(seqIntervalId); seqIntervalId = null;
            if(seqPlayStopBtn) { seqPlayStopBtn.textContent = "Play"; seqPlayStopBtn.classList.remove('active');}
            sequencerGridDiv?.querySelectorAll(`.sequencer-step.current`).forEach(div => div.classList.remove('current'));
            Object.keys(activeOscillators).forEach(id => { 
                if (activeOscillators[id] && (activeOscillators[id].source === 'sequencer' || 
                                              activeOscillators[id].source === 'sequencer_drum_sample' ||
                                              activeOscillators[id].source === 'sequencer_drum_synth')
                   ) { 
                    stopSound(id, 0.01); 
                }
            });
        }
        
        async function loadCustomDrumSample(event, drumIndex) {
            const file = event.target.files[0];
            if (!file) { return; }
            await initAudioContext();

            const drumName = DRUM_ROW_NAMES[drumIndex];
            if (!drumName) {
                console.error(`Invalid drum index: ${drumIndex}`);
                return;
            }

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const arrayBuffer = e.target.result;
                    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    drumSamples[drumName] = audioBuffer;
                    console.log(`Custom sample for ${drumName} loaded and decoded successfully.`);
                    alert(`New sample for "${drumName}" loaded!`);
                } catch (error) {
                    console.error(`Error loading or decoding custom sample for ${drumName}:`, error);
                    alert(`Failed to load sample for "${drumName}". Please ensure it's a valid WAV file. Error: ${error.message}`);
                    drumSamples[drumName] = null;
                }
            };
            reader.readAsArrayBuffer(file);
            if (event.target) event.target.value = null;
        }

        function audioBufferToBase64(buffer) {
            if (!buffer) return null;
            const channels = [];
            for (let i = 0; i < buffer.numberOfChannels; i++) {
                const channelData = buffer.getChannelData(i);
                const uint8Array = new Uint8Array(channelData.buffer);
                let binary = '';
                for (let j = 0; j < uint8Array.length; j++) {
                    binary += String.fromCharCode(uint8Array[j]);
                }
                channels.push(window.btoa(binary));
            }
            return {
                sampleRate: buffer.sampleRate,
                length: buffer.length,
                numberOfChannels: buffer.numberOfChannels,
                channels: channels
            };
        }

        async function base64ToAudioBuffer(data) {
            if (!data || !audioContext) return null;
            const { sampleRate, length, numberOfChannels, channels } = data;
            const newBuffer = audioContext.createBuffer(numberOfChannels, length, sampleRate);

            for (let i = 0; i < numberOfChannels; i++) {
                const binary = window.atob(channels[i]);
                const len = binary.length;
                const bytes = new Uint8Array(len);
                for (let j = 0; j < len; j++) {
                    bytes[j] = binary.charCodeAt(j);
                }
                const float32Array = new Float32Array(bytes.buffer);
                newBuffer.copyToChannel(float32Array, i);
            }
            return newBuffer;
        }

        function saveSequence() {
            const savedDrumSamples = {};
            for (const drumName of DRUM_ROW_NAMES) {
                if (drumSamples[drumName]) {
                    savedDrumSamples[drumName] = audioBufferToBase64(drumSamples[drumName]);
                }
            }

            const dataToSave = { 
                version: 2.4,
                numPianoKeys: NUM_PIANO_KEYS, 
                currentMaxKeysPerRow: currentMaxKeysPerRow, 
                keysData: keysData,
                skin: currentSkin,
                keyShape: currentKeyShape,
                numSeqMelodicRows: NUM_SEQ_MELODIC_ROWS, 
                sequencerData: sequencerData, 
                numSeqSteps: NUM_SEQ_STEPS, 
                tempo: currentSeqTempoBPM, 
                rootNote: currentRootNoteName, 
                octaveOffset: currentOctaveOffset,
                seqRowKeyIndices: SEQ_ROW_KEY_INDICES, 
                keysVolume: keysMasterGain ? keysMasterGain.gain.value : 0.7,
                sequencerVolume: sequencerMasterGain ? sequencerMasterGain.gain.value : 0.7, 
                soundTypeKeys: currentSoundTypeKeys, 
                soundTypeSeq: currentSoundTypeSeq,
                soundDefinitionFunctionBody: soundDefinitionFunctionBody,
                numChords: NUM_CHORDS,
                fullChordDefinitions: chordDefinitions,
                savedDrumSamples: savedDrumSamples,
                rootCFrequency: rootCFrequency,
                masterRootNoteRatios: masterRootNoteRatios,
                isRootDynamic: isRootDynamic,
                isKeyEditMode: isKeyEditMode,
                areRowsStaggered: areRowsStaggered,
                modWheelTarget: modWheelTarget,
                isEdoModeActive: isEdoModeActive
            };
            const jsonString = JSON.stringify(dataToSave, null, 2); 
            const blob = new Blob([jsonString], { type: "application/json" });
            const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = "tunable_session_v2.4.json"; 
            document.body.appendChild(a);
            a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); alert("Session saved!");
        }

        async function loadSequence(event) { 
            const file = event.target.files[0]; if (!file) return; const reader = new FileReader();
            reader.onload = async (e) => { try { 
                    const loadedData = JSON.parse(e.target.result);

                    if (loadedData.skin) {
                        applySkin(loadedData.skin);
                        if(skinSelect) skinSelect.value = loadedData.skin;
                    }
                    if (loadedData.keyShape) {
                        applyKeyShape(loadedData.keyShape);
                        if(keyShapeSelect) keyShapeSelect.value = loadedData.keyShape;
                    }

                    if (typeof loadedData.isKeyEditMode === 'boolean') {
                        setKeyEditMode(loadedData.isKeyEditMode);
                    }
                     if (typeof loadedData.areRowsStaggered === 'boolean') {
                        setRowStagger(loadedData.areRowsStaggered);
                    }
                    if (typeof loadedData.modWheelTarget === 'string' && modWheelSelect) {
                        modWheelTarget = loadedData.modWheelTarget;
                        modWheelSelect.value = modWheelTarget;
                    }

                    for (const drumName of DRUM_ROW_NAMES) {
                        drumSamples[drumName] = null;
                    }
                    
                    if (typeof loadedData.rootCFrequency === 'number') {
                        rootCFrequency = loadedData.rootCFrequency;
                    }
                    if (Array.isArray(loadedData.masterRootNoteRatios) && loadedData.masterRootNoteRatios.length === 12) {
                        masterRootNoteRatios = loadedData.masterRootNoteRatios;
                    } else if (Array.isArray(loadedData.rootNoteRatios) && loadedData.rootNoteRatios.length === 12) { // Legacy support
                        masterRootNoteRatios = loadedData.rootNoteRatios;
                    } else {
                        masterRootNoteRatios = [...JUST_INTONATION_RATIOS];
                    }
                    
                    isRootDynamic = !!loadedData.isRootDynamic;
                    const dynamicRootBtn = document.getElementById('toggle-dynamic-root-btn');
                    dynamicRootBtn.textContent = `Root: ${isRootDynamic ? 'Dynamic' : 'Static'}`;
                    dynamicRootBtn.classList.toggle('active', isRootDynamic);

                    isEdoModeActive = !!loadedData.isEdoModeActive;
                    if (applyTuningBtn) {
                        applyTuningBtn.textContent = isEdoModeActive ? 'Apply JI' : 'Apply EDO';
                    }
                    
                    rootNoteRatios = [...masterRootNoteRatios]; // Start with the master
                    generateRootTuningControls();
                    recalculateBaseFrequencies();

                    if (loadedData.keysData && Array.isArray(loadedData.keysData)) {
                        keysData = loadedData.keysData;
                        NUM_PIANO_KEYS = keysData.length;
                        if (numPianoKeysInput) numPianoKeysInput.value = NUM_PIANO_KEYS;
                    } else { 
                        NUM_PIANO_KEYS = loadedData.numPianoKeys || 13;
                        if (numPianoKeysInput) numPianoKeysInput.value = NUM_PIANO_KEYS;
                        resizeKeyDataArray();
                        if(loadedData.keyBaseIntervalStrings) {
                           keysData.forEach((key, i) => {
                               if(key && loadedData.keyBaseIntervalStrings[i] !== undefined) {
                                   key.interval = loadedData.keyBaseIntervalStrings[i];
                               }
                           });
                        }
                    }
                    
                    if (typeof loadedData.currentMaxKeysPerRow === 'number') { currentMaxKeysPerRow = loadedData.currentMaxKeysPerRow; if(maxKeysPerRowInput) maxKeysPerRowInput.value = currentMaxKeysPerRow;}
                    else { currentMaxKeysPerRow = 13; if(maxKeysPerRowInput) maxKeysPerRowInput.value = 13;}

                    if (typeof loadedData.numSeqMelodicRows === 'number') { 
                        NUM_SEQ_MELODIC_ROWS = loadedData.numSeqMelodicRows; 
                        if(numSeqRowsInput) numSeqRowsInput.value = NUM_SEQ_MELODIC_ROWS;
                    } else { 
                        NUM_SEQ_MELODIC_ROWS = (typeof loadedData.numSeqRows === 'number') ? loadedData.numSeqRows : 4;
                        if(numSeqRowsInput) numSeqRowsInput.value = NUM_SEQ_MELODIC_ROWS;
                    }

                    await createPianoKeysAndRootSelector(); 

                    if (typeof loadedData.numSeqSteps === 'number') { NUM_SEQ_STEPS = loadedData.numSeqSteps; if(numSeqStepsInput) numSeqStepsInput.value = NUM_SEQ_STEPS; }
                    
                    const totalRowsToLoad = NUM_DRUM_ROWS + NUM_SEQ_MELODIC_ROWS;
                    sequencerData = Array(totalRowsToLoad).fill(null).map((_,r) => {
                        const newRow = Array(NUM_SEQ_STEPS).fill(false);
                        if (loadedData.sequencerData && loadedData.sequencerData[r]) {
                            for (let s = 0; s < Math.min(loadedData.sequencerData[r].length, NUM_SEQ_STEPS); s++) {
                                newRow[s] = loadedData.sequencerData[r][s] || false;
                            }
                        }
                        return newRow;
                    });
                    
                    SEQ_ROW_KEY_INDICES = Array(NUM_SEQ_MELODIC_ROWS); 
                     if (loadedData.seqRowKeyIndices) {
                        for (let i = 0; i < NUM_SEQ_MELODIC_ROWS; i++) {
                            if (i < loadedData.seqRowKeyIndices.length && loadedData.seqRowKeyIndices[i] !== undefined) {
                                const potentialIndex = Math.min(loadedData.seqRowKeyIndices[i], NUM_PIANO_KEYS > 0 ? NUM_PIANO_KEYS - 1 : 0);
                                SEQ_ROW_KEY_INDICES[i] = keysData[potentialIndex] ? potentialIndex : keysData.findIndex(k => k !== null);
                            } else {
                                SEQ_ROW_KEY_INDICES[i] = keysData.findIndex(k => k !== null); // Find first valid key
                            }
                        }
                    } else { 
                         for (let i = 0; i < NUM_SEQ_MELODIC_ROWS; i++) {
                            const firstValidKeyIndex = keysData.findIndex(k => k !== null);
                            SEQ_ROW_KEY_INDICES[i] = firstValidKeyIndex !== -1 ? firstValidKeyIndex : undefined;
                        }
                    }

                    if (loadedData.rootNote && NOTE_NAMES.includes(loadedData.rootNote)) { currentRootNoteName = loadedData.rootNote; }
                    selectRootNote(currentRootNoteName); // This will correctly apply dynamic root if it was on
                    
                    if (typeof loadedData.octaveOffset === 'number') { currentOctaveOffset = loadedData.octaveOffset; }
                    
                    if (isSequencerPlaying) stopSequencer(); 
                    
                    if (typeof loadedData.tempo === 'number') {
                        updateSequencerTempo(loadedData.tempo);
                        if(seqTempoSlider) seqTempoSlider.value = loadedData.tempo;
                        if(seqTempoInput) seqTempoInput.value = loadedData.tempo;
                    }

                    createSequencerGrid(); 
                    
                    if (typeof loadedData.keysVolume === 'number' && keysVolumeSlider) { keysVolumeSlider.value = loadedData.keysVolume; if(keysMasterGain) keysMasterGain.gain.value = loadedData.keysVolume; }
                    if (typeof loadedData.sequencerVolume === 'number' && sequencerVolumeSlider) { sequencerVolumeSlider.value = loadedData.sequencerVolume; if(sequencerMasterGain) sequencerMasterGain.gain.value = loadedData.sequencerVolume; }
                    
                    if (typeof loadedData.soundDefinitionFunctionBody === 'string') {
                        try {
                            new Function('soundType', 'frequency', 'now', 'audioContext', 'masterGainNode', 'soundId', 'activeOscillators', loadedData.soundDefinitionFunctionBody);
                            soundDefinitionFunctionBody = loadedData.soundDefinitionFunctionBody;
                            currentSoundGenerator = new Function('soundType', 'frequency', 'now', 'audioContext', 'masterGainNode', 'soundId', 'activeOscillators', soundDefinitionFunctionBody);
                        } catch (synthError) {
                            console.error("Error validating sound definitions from session file:", synthError);
                            alert("Could not load custom sound definitions from session file. Reverting to default. Check console.");
                        }
                    }
                    const soundNamesToList = extractSoundNames(soundDefinitionFunctionBody);
                    updateSoundSelectors(soundNamesToList); 

                    if (loadedData.soundTypeKeys && soundTypeKeysSelect && soundNamesToList.includes(loadedData.soundTypeKeys)) {
                        currentSoundTypeKeys = loadedData.soundTypeKeys; soundTypeKeysSelect.value = currentSoundTypeKeys; 
                    } else if (soundNamesToList.length > 0) { currentSoundTypeKeys = soundNamesToList[0]; soundTypeKeysSelect.value = currentSoundTypeKeys; }

                    if (loadedData.soundTypeSeq && soundTypeSeqSelect && soundNamesToList.includes(loadedData.soundTypeSeq)) { 
                        currentSoundTypeSeq = loadedData.soundTypeSeq; soundTypeSeqSelect.value = currentSoundTypeSeq; 
                    } else if (soundNamesToList.length > 0) { currentSoundTypeSeq = soundNamesToList[0]; soundTypeSeqSelect.value = currentSoundTypeSeq; }

                    if (typeof loadedData.numChords === 'number') {
                        NUM_CHORDS = loadedData.numChords;
                        numChordsInput.value = NUM_CHORDS;
                    }
                    
                    if (loadedData.fullChordDefinitions) {
                        chordDefinitions = loadedData.fullChordDefinitions;
                        for (const type in chordDefinitions) {
                            if (chordDefinitions[type]) {
                                chordDefinitions[type].currentKeyIndices = chordDefinitions[type].currentKeyIndices.map(ki => {
                                    if (ki === null) return null;
                                    let newIndexValue;
                                    if (typeof ki === 'object') {
                                        newIndexValue = Math.max(0, Math.min(ki.keyIndex, NUM_PIANO_KEYS > 0 ? NUM_PIANO_KEYS - 1 : 0));
                                        return { ...ki, keyIndex: newIndexValue };
                                    } else {
                                        newIndexValue = Math.max(0, Math.min(ki, NUM_PIANO_KEYS > 0 ? NUM_PIANO_KEYS - 1 : 0));
                                        return newIndexValue;
                                    }
                                }).slice(0, chordDefinitions[type].numNotes); 
                            }
                        }
                    }
                    rebuildAllChordUIFromDefinitions();

                    if (loadedData.savedDrumSamples) {
                        for (const drumName in loadedData.savedDrumSamples) {
                            if (DRUM_ROW_NAMES.includes(drumName) && loadedData.savedDrumSamples[drumName]) {
                                try {
                                    const buffer = await base64ToAudioBuffer(loadedData.savedDrumSamples[drumName]);
                                    drumSamples[drumName] = buffer;
                                    console.log(`Restored custom drum sample for ${drumName} from file.`);
                                } catch (e) {
                                    console.error(`Failed to restore custom sample for ${drumName}:`, e);
                                    drumSamples[drumName] = null;
                                }
                            }
                        }
                    }

                    updateOctaveDisplay(); 
                    updateKeyDisplays(); 
                    alert("Session loaded!");
                } catch (error) { console.error("Error loading session:", error); alert("Failed to load session file. Error: " + error.message); }};
            reader.readAsText(file); if(event.target) event.target.value = null; 
        }

        function rebuildAllChordUIFromDefinitions() {
            if (chordButtonsRowDiv) chordButtonsRowDiv.innerHTML = ''; 
            numChordsInput.value = NUM_CHORDS;

            for (let i = 0; i < NUM_CHORDS; i++) {
                const chordId = `cho${i + 1}`;
                if (!chordDefinitions[chordId]) { 
                    const defaultNumNotes = 4;
                    chordDefinitions[chordId] = {
                        name: `Chord ${i + 1}`,
                        numNotes: defaultNumNotes,
                        currentKeyIndices: Array(defaultNumNotes).fill(null),
                        labels: Array(defaultNumNotes).fill(null).map((_, j) => `Note ${j + 1}`)
                    };
                }
                buildChordGroupUI(chordId); 
                createChordKeySelectors(chordId); 
            }
        }

        function TICKS_PER_BEAT() {
            return 128;
        }

        function exportMIDI() {
            function stringToBytes(str) { const bytes = []; for (let i = 0; i < str.length; i++) { bytes.push(str.charCodeAt(i)); } return bytes; }
            function numberToBytes(num, byteCount) { const bytes = []; for (let i = byteCount - 1; i >= 0; i--) { bytes.push((num >> (i * 8)) & 0xFF); } return bytes;}
            function encodeVLQ(value) { const result = []; let v = value; const tempBytes = []; tempBytes.push(v & 0x7F); v >>= 7;
                while (v > 0) { tempBytes.push(v & 0x7F); v >>= 7; }
                while (tempBytes.length > 0) { let b = tempBytes.pop(); if (tempBytes.length > 0) { b |= 0x80; } result.push(b); }
                return result.length > 0 ? result : [0]; 
            }
            const midiFileBytes = []; const tracksData = []; 
            const totalRows = NUM_DRUM_ROWS + NUM_SEQ_MELODIC_ROWS;
            const ticksPerBeat = TICKS_PER_BEAT();

            const DRUM_MIDI_NOTES = { "Kick": 36, "Snare": 38, "Hi-Hat": 42 }; 
            const DRUM_MIDI_CHANNEL = 9; 

            let drumTrackHasNotes = false;
            const drumTrackEvents = [];
            let drumCurrentAbsoluteTick = 0;
            const drumTrackName = "Drums";
            const drumTrackNameBytes = stringToBytes(drumTrackName);
            drumTrackEvents.push({ delta: 0, eventBytes: [0xFF, 0x03, drumTrackNameBytes.length, ...drumTrackNameBytes]});

            if (tracksData.length === 0) { 
                const microSecondsPerBeat = Math.round(60000000 / currentSeqTempoBPM);
                drumTrackEvents.push({ delta: 0, eventBytes: [0xFF, 0x51, 0x03, ...numberToBytes(microSecondsPerBeat, 3)] });
            }

            const drumTimedEvents = [];
            for (let drumRowIndex = 0; drumRowIndex < NUM_DRUM_ROWS; drumRowIndex++) {
                const drumName = DRUM_ROW_NAMES[drumRowIndex];
                const midiNote = DRUM_MIDI_NOTES[drumName];
                if (midiNote === undefined) continue;

                for (let s = 0; s < NUM_SEQ_STEPS; s++) {
                    if (sequencerData[drumRowIndex] && sequencerData[drumRowIndex][s]) {
                        drumTrackHasNotes = true;
                        const noteStartTick = s * (ticksPerBeat / 4);
                        const noteDurationTicks = ticksPerBeat / 4; 
                        const noteEndTick = noteStartTick + noteDurationTicks;
                        const velocity = 100;
                        drumTimedEvents.push({ tick: noteStartTick, type: 'on', bytes: [0x90 | DRUM_MIDI_CHANNEL, midiNote, velocity] });
                        drumTimedEvents.push({ tick: noteEndTick, type: 'off', bytes: [0x80 | DRUM_MIDI_CHANNEL, midiNote, 0] });
                    }
                }
            }
            if (drumTrackHasNotes) {
                drumTimedEvents.sort((a,b) => a.tick - b.tick || (a.type === 'off' ? 1 : -1)); 
                for (const event of drumTimedEvents) {
                    const delta = event.tick - drumCurrentAbsoluteTick;
                    drumTrackEvents.push({ delta: delta, eventBytes: event.bytes });
                    drumCurrentAbsoluteTick = event.tick;
                }
                const endOfDrumSequenceTick = NUM_SEQ_STEPS * (ticksPerBeat / 4);
                const deltaToEndDrums = Math.max(0, endOfDrumSequenceTick - drumCurrentAbsoluteTick);
                drumTrackEvents.push({ delta: deltaToEndDrums, eventBytes: [0xFF, 0x2F, 0x00] });
                tracksData.push(drumTrackEvents);
            }

            for (let melodicRow = 0; melodicRow < NUM_SEQ_MELODIC_ROWS; melodicRow++) {
                const dataRowIndex = NUM_DRUM_ROWS + melodicRow;
                const keyIndexToPlay = SEQ_ROW_KEY_INDICES[melodicRow];

                if (keyIndexToPlay === undefined || keyIndexToPlay === null || keyIndexToPlay < 0 || keyIndexToPlay >= NUM_PIANO_KEYS || !keysData[keyIndexToPlay]) continue;
                let rowHasNotes = false; 
                for (let s = 0; s < NUM_SEQ_STEPS; s++) { 
                    if (sequencerData[dataRowIndex] && sequencerData[dataRowIndex][s]) { 
                        rowHasNotes = true; break; 
                    }
                }
                if (!rowHasNotes) continue; 
                
                let midiChannel;
                if (melodicRow < DRUM_MIDI_CHANNEL) { 
                    midiChannel = melodicRow;
                } else if (melodicRow < 15) { 
                    midiChannel = melodicRow + 1; 
                } else {
                    continue; 
                }

                const trackEventsList = [];  let currentAbsoluteTick = 0; 
                const trackName = `Melody ${melodicRow + 1}`; const trackNameBytes = stringToBytes(trackName);
                trackEventsList.push({ delta: 0, eventBytes: [0xFF, 0x03, trackNameBytes.length, ...trackNameBytes] });
                
                if (tracksData.length === 0) { 
                    const microSecondsPerBeat = Math.round(60000000 / currentSeqTempoBPM);
                    trackEventsList.push({ delta: 0, eventBytes: [0xFF, 0x51, 0x03, ...numberToBytes(microSecondsPerBeat, 3)] }); 
                }

                trackEventsList.push({ delta: 0, eventBytes: [0xB0 | midiChannel, 101, 0] }); 
                trackEventsList.push({ delta: 0, eventBytes: [0xB0 | midiChannel, 100, 0] });
                trackEventsList.push({ delta: 0, eventBytes: [0xB0 | midiChannel, 6, PITCH_BEND_RANGE_SEMITONES] }); 
                trackEventsList.push({ delta: 0, eventBytes: [0xB0 | midiChannel, 38, 0] });
                
                const timedEvents = []; let lastKnownPitchBendOnChannel = 8192; 
                for (let s = 0; s < NUM_SEQ_STEPS; s++) {
                    if (sequencerData[dataRowIndex] && sequencerData[dataRowIndex][s]) {
                        const freqObject = getFrequencyForKey(keyIndexToPlay); 
                        if (freqObject === null) continue;
                        const freq = freqObject.baseFreq; // Use base frequency for MIDI export
                        const midiNoteValue = 69 + 12 * Math.log2(freq / 440.0); const closestMidiNote = Math.max(0, Math.min(127, Math.round(midiNoteValue)));
                        const deviationSemitones = midiNoteValue - closestMidiNote; let pitchBendActual = 8192; 
                        if (Math.abs(deviationSemitones) > 0.001) { const pitchBendUnits = (deviationSemitones / PITCH_BEND_RANGE_SEMITONES) * 8191;
                            pitchBendActual = Math.round(8192 + pitchBendUnits); pitchBendActual = Math.max(0, Math.min(16383, pitchBendActual)); }
                        const pitchBendLSB = pitchBendActual & 0x7F; const pitchBendMSB = (pitchBendActual >> 7) & 0x7F;
                        const noteStartTick = s * (ticksPerBeat / 4); const noteDurationTicks = ticksPerBeat / 4; 
                        const noteEndTick = noteStartTick + noteDurationTicks; const velocity = 100; 
                        if (pitchBendActual !== lastKnownPitchBendOnChannel) {
                            timedEvents.push({ tick: noteStartTick, type: 'pb', bytes: [0xE0 | midiChannel, pitchBendLSB, pitchBendMSB] });
                            lastKnownPitchBendOnChannel = pitchBendActual; }
                        timedEvents.push({ tick: noteStartTick, type: 'on', bytes: [0x90 | midiChannel, closestMidiNote, velocity] });
                        timedEvents.push({ tick: noteEndTick, type: 'off', bytes: [0x80 | midiChannel, closestMidiNote, 0] });
                    }}
                timedEvents.sort((a, b) => { if (a.tick !== b.tick) return a.tick - b.tick; const typeOrder = { 'pb': 0, 'on': 1, 'off': 2 }; return typeOrder[a.type] - typeOrder[b.type]; });
                for (const event of timedEvents) { const delta = event.tick - currentAbsoluteTick; trackEventsList.push({ delta: delta, eventBytes: event.bytes }); currentAbsoluteTick = event.tick; }
                const endOfSequenceTick = NUM_SEQ_STEPS * (ticksPerBeat / 4); const deltaToEnd = Math.max(0, endOfSequenceTick - currentAbsoluteTick);
                trackEventsList.push({ delta: deltaToEnd, eventBytes: [0xFF, 0x2F, 0x00] }); 
                tracksData.push(trackEventsList);
            }

            if (tracksData.length === 0) { alert("No notes in sequencer to export."); return; }

            midiFileBytes.push(...stringToBytes('MThd')); midiFileBytes.push(...numberToBytes(6, 4)); midiFileBytes.push(...numberToBytes(1, 2)); 
            midiFileBytes.push(...numberToBytes(tracksData.length, 2)); midiFileBytes.push(...numberToBytes(ticksPerBeat, 2)); 
            for (const trackEvents of tracksData) { const trackChunkBytes = [];
                for (const event of trackEvents) { trackChunkBytes.push(...encodeVLQ(event.delta)); trackChunkBytes.push(...event.eventBytes); }
                midiFileBytes.push(...stringToBytes('MTrk')); midiFileBytes.push(...numberToBytes(trackChunkBytes.length, 4)); midiFileBytes.push(...trackChunkBytes);
            }
            const byteArray = new Uint8Array(midiFileBytes); const blob = new Blob([byteArray], { type: 'audio/midi' });
            const url = URL.createObjectURL(blob); const link = document.createElement('a'); link.href = url; link.download = 'sequencer_output.mid';
            document.body.appendChild(link); link.click(); document.body.removeChild(link); URL.revokeObjectURL(url); alert("MIDI file exported!");
        }

        function recalculateBaseFrequencies() {
            currentBaseFrequencies = {};
            for (let i = 0; i < NOTE_NAMES.length; i++) {
                const noteName = NOTE_NAMES[i];
                currentBaseFrequencies[noteName] = rootCFrequency * rootNoteRatios[i];
            }
        }

        function updateRootTuningInputs() {
            const cInput = document.getElementById('root-c-freq-input');
            if (cInput) cInput.value = rootCFrequency.toFixed(2);

            for (let i = 1; i < NOTE_NAMES.length; i++) {
                const input = document.getElementById(`root-ratio-input-${i}`);
                if (input) {
                    input.value = decimalToFractionString(rootNoteRatios[i], 128);
                }
            }
        }

        function generateRootTuningControls() {
            const container = document.getElementById('root-tuning-controls');
            if (!container) return;
            container.innerHTML = '';

            const cGroup = document.createElement('div');
            cGroup.classList.add('control-group');
            const cLabel = document.createElement('label');
            cLabel.htmlFor = 'root-c-freq-input';
            cLabel.textContent = 'C4 Freq (Hz):';
            const cInput = document.createElement('input');
            cInput.type = 'number';
            cInput.id = 'root-c-freq-input';
            cInput.value = rootCFrequency.toFixed(2);
            cInput.style.width = '70px';
            cGroup.appendChild(cLabel);
            cGroup.appendChild(cInput);
            container.appendChild(cGroup);

            for (let i = 1; i < NOTE_NAMES.length; i++) {
                const noteName = NOTE_NAMES[i];
                const group = document.createElement('div');
                group.classList.add('control-group');
                const label = document.createElement('label');
                label.htmlFor = `root-ratio-input-${i}`;
                label.textContent = `${noteName} Ratio:`;
                const input = document.createElement('input');
                input.type = 'text';
                input.id = `root-ratio-input-${i}`;
                input.value = decimalToFractionString(rootNoteRatios[i], 128);
                input.style.width = '70px';
                group.appendChild(label);
                group.appendChild(input);
                container.appendChild(group);
            }

            const applyBtn = document.createElement('button');
            applyBtn.id = 'apply-custom-tuning-btn';
            applyBtn.textContent = 'Apply Tuning';
            applyBtn.classList.add('control-button');
            applyBtn.style.fontSize = "0.8em";
            applyBtn.style.padding = "5px 8px";
            applyBtn.addEventListener('click', () => {
                try {
                    const newCFreq = parseFloat(document.getElementById('root-c-freq-input').value);
                    if (isNaN(newCFreq) || newCFreq <= 0) {
                        alert('Invalid C frequency. Must be a positive number.');
                        return;
                    }
                    rootCFrequency = newCFreq;

                    const newRatios = [1.0];
                    for (let i = 1; i < NOTE_NAMES.length; i++) {
                        const ratioStr = document.getElementById(`root-ratio-input-${i}`).value;
                        const newRatio = parseRatio(ratioStr);
                        if (isNaN(newRatio) || newRatio <= 0) {
                            alert(`Invalid ratio for ${NOTE_NAMES[i]}. Must be a positive number or fraction.`);
                            return;
                        }
                        newRatios.push(newRatio);
                    }
                    masterRootNoteRatios = newRatios; // Save user's custom tuning as the new master
                    rootNoteRatios = [...masterRootNoteRatios];

                    recalculateBaseFrequencies();
                    selectRootNote(currentRootNoteName); 
                    alert('Custom tuning applied!');
                } catch (error) {
                    alert('Error applying tuning: ' + error.message);
                }
            });
            container.appendChild(applyBtn);
        }
        
        function setupMIDI() {
            midiInSelect = document.getElementById('midi-in-select');
            midiOutSelect = document.getElementById('midi-out-select');
            midiInToggleButton = document.getElementById('midi-in-toggle-btn');
            midiOutToggleButton = document.getElementById('midi-out-toggle-btn');
            modWheelSelect = document.getElementById('midi-mod-wheel-select');

            if (navigator.requestMIDIAccess) {
                navigator.requestMIDIAccess({ sysex: false })
                    .then(onMIDISuccess, onMIDIFailure);
            } else {
                console.warn("WebMIDI is not supported in this browser.");
                midiInToggleButton.disabled = true;
                midiOutToggleButton.disabled = true;
                midiInSelect.disabled = true;
                midiOutSelect.disabled = true;
            }

            midiInToggleButton.addEventListener('click', toggleMidiIn);
            midiOutToggleButton.addEventListener('click', toggleMidiOut);
            midiInSelect.addEventListener('change', setMidiInput);
            midiOutSelect.addEventListener('change', setMidiOutput);
            modWheelSelect.addEventListener('change', (e) => {
                modWheelTarget = e.target.value;
            });
        }

        function onMIDISuccess(m) {
            midiAccess = m;
            updateMidiDeviceLists();
            midiAccess.onmidistatechange = updateMidiDeviceLists;
        }

        function onMIDIFailure(msg) {
            console.error(`Failed to get MIDI access - ${msg}`);
            alert(`Failed to get MIDI access. Please ensure your browser has permissions.`);
        }

        function updateMidiDeviceLists() {
            if (!midiAccess) return;
            midiInSelect.innerHTML = '';
            if (midiAccess.inputs.size > 0) {
                midiAccess.inputs.forEach(input => {
                    const option = document.createElement('option');
                    option.value = input.id;
                    option.textContent = input.name;
                    midiInSelect.appendChild(option);
                });
            } else {
                midiInSelect.innerHTML = '<option value="">(No devices)</option>';
            }
            setMidiInput();

            midiOutSelect.innerHTML = '';
            if (midiAccess.outputs.size > 0) {
                midiAccess.outputs.forEach(output => {
                    const option = document.createElement('option');
                    option.value = output.id;
                    option.textContent = output.name;
                    midiOutSelect.appendChild(option);
                });
            } else {
                midiOutSelect.innerHTML = '<option value="">(No devices)</option>';
            }
            setMidiOutput();
        }
        
        function setMidiInput() {
            if (selectedMidiInput) {
                selectedMidiInput.onmidimessage = null;
            }
            const selectedId = midiInSelect.value;
            selectedMidiInput = midiAccess.inputs.get(selectedId);
            if (selectedMidiInput && isMidiInActive) {
                selectedMidiInput.onmidimessage = handleMidiMessage;
            }
        }
        
        function setMidiOutput() {
            const selectedId = midiOutSelect.value;
            selectedMidiOutput = midiAccess.outputs.get(selectedId);
        }

        function toggleMidiIn() {
            isMidiInActive = !isMidiInActive;
            midiInToggleButton.textContent = isMidiInActive ? "On" : "Off";
            midiInToggleButton.classList.toggle('active', isMidiInActive);
            setMidiInput(); 
        }

        function toggleMidiOut() {
            isMidiOutActive = !isMidiOutActive;
            midiOutToggleButton.textContent = isMidiOutActive ? "On" : "Off";
            midiOutToggleButton.classList.toggle('active', isMidiOutActive);
        }
        
        async function handleMidiMessage(event) {
            const command = event.data[0] & 0xF0;
            const note = event.data[1];
            const velocity = event.data[2];
            const MIDI_C4 = 60;
            const keyIndex = note - MIDI_C4;

            if (command === 0x90 && velocity > 0) { // Note On
                if (keyIndex < 0 || keyIndex >= NUM_PIANO_KEYS || !keysData[keyIndex]) return;

                const targetKeyElement = document.querySelector(`.piano-key[data-key-index="${keyIndex}"]`);
                const soundId = `keyboard_key_${keyIndex}`;
                
                if (!activeKeyboardNotes[keyIndex]) {
                    activeKeyboardNotes[keyIndex] = true;
                    if (targetKeyElement) {
                        await initAudioContext();
                        const freqObject = getFrequencyForKey(keyIndex);
                        if (freqObject !== null) {
                            playSound(freqObject, soundId, 'key');
                            targetKeyElement.classList.add('keyboard-playing');
                        }
                    }
                }
            } else if (command === 0x80 || (command === 0x90 && velocity === 0)) { // Note Off
                 if (keyIndex < 0 || keyIndex >= NUM_PIANO_KEYS) return;
                 const soundId = `keyboard_key_${keyIndex}`;
                 if (activeKeyboardNotes[keyIndex]) {
                    activeKeyboardNotes[keyIndex] = false;
                    stopSound(soundId);
                    const targetKeyElement = document.querySelector(`.piano-key[data-key-index="${keyIndex}"]`);
                    if (targetKeyElement) {
                        targetKeyElement.classList.remove('keyboard-playing');
                    }
                }
            } else if (command === 0xE0) { // Pitch Bend
                const pitchBendValue = (event.data[2] << 7) | event.data[1];
                const normalizedBend = (pitchBendValue - 8192) / 8192;
                globalPitchShiftSemitones = normalizedBend * PITCH_BEND_RANGE_SEMITONES;
                updatePitchShiftUI();
                updateAllActiveNotePitches();
            } else if (command === 0xB0) { // Control Change
                const ccNumber = event.data[1];
                const ccValue = event.data[2];
                if (ccNumber === 1) { // Mod Wheel (CC #1)
                    handleModWheel(ccValue);
                }
            }
        }

        function handleModWheel(value) { // value is 0-127
            const normalizedValue = value / 127.0;

            switch(modWheelTarget) {
                case 'keys_vol':
                    if (keysMasterGain) keysMasterGain.gain.setTargetAtTime(normalizedValue, audioContext.currentTime, 0.01);
                    if (keysVolumeSlider) keysVolumeSlider.value = normalizedValue;
                    break;
                case 'seq_vol':
                    if (sequencerMasterGain) sequencerMasterGain.gain.setTargetAtTime(normalizedValue, audioContext.currentTime, 0.01);
                    if (sequencerVolumeSlider) sequencerVolumeSlider.value = normalizedValue;
                    break;
                case 'tempo':
                    const minTempo = parseFloat(seqTempoSlider.min) || 30;
                    const maxTempo = parseFloat(seqTempoSlider.max) || 280;
                    const newTempo = minTempo + normalizedValue * (maxTempo - minTempo);
                    updateSequencerTempo(Math.round(newTempo));
                    if (seqTempoSlider) seqTempoSlider.value = Math.round(newTempo);
                    if (seqTempoInput) seqTempoInput.value = Math.round(newTempo);
                    break;
                case 'pitch':
                    const minPitch = parseFloat(pitchShiftSlider.min) || -2;
                    const maxPitch = parseFloat(pitchShiftSlider.max) || 2;
                    globalPitchShiftSemitones = minPitch + normalizedValue * (maxPitch - minPitch);
                    updatePitchShiftUI();
                    updateAllActiveNotePitches();
                    break;
                case 'none':
                default:
                    return;
            }
        }


        async function handleDocumentKeyDown(event) {
            const activeElement = document.activeElement;
            const isTypingInInput = activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'SELECT' || activeElement.isContentEditable);
            if (isTypingInInput) return; 
            const key = event.key.toLowerCase(); const rawKey = event.key; 
            if (ROOT_NOTE_KEY_MAP[rawKey]) { event.preventDefault(); selectRootNote(ROOT_NOTE_KEY_MAP[rawKey]); return; }
            const pianoKeyIndex = PIANO_KEY_COMPUTER_KEY_MAP.indexOf(key);
            if (pianoKeyIndex !== -1 && pianoKeyIndex < NUM_PIANO_KEYS && keysData[pianoKeyIndex]) { 
                event.preventDefault();
                if (!activeKeyboardNotes[pianoKeyIndex]) { 
                    activeKeyboardNotes[pianoKeyIndex] = true;
                    const targetKeyElement = document.querySelector(`.piano-key[data-key-index="${pianoKeyIndex}"]`);
                    if (targetKeyElement) { 
                        await initAudioContext(); 
                        const freqObject = getFrequencyForKey(pianoKeyIndex);
                        if (freqObject !== null) { 
                            playSound(freqObject, `keyboard_key_${pianoKeyIndex}`, 'key'); 
                            targetKeyElement.classList.add('keyboard-playing'); 
                        }
                    }
                }
            }
        }

        function handleDocumentKeyUp(event) {
            const key = event.key.toLowerCase(); const rawKey = event.key;
            const pianoKeyIndex = PIANO_KEY_COMPUTER_KEY_MAP.indexOf(key);
            if (pianoKeyIndex !== -1 && pianoKeyIndex < NUM_PIANO_KEYS && keysData[pianoKeyIndex]) { 
                event.preventDefault();
                if (activeKeyboardNotes[pianoKeyIndex]) { activeKeyboardNotes[pianoKeyIndex] = false; stopSound(`keyboard_key_${pianoKeyIndex}`);
                    const targetKeyElement = document.querySelector(`.piano-key[data-key-index="${pianoKeyIndex}"]`);
                    targetKeyElement?.classList.remove('keyboard-playing'); 
                }
            }
             if (ROOT_NOTE_KEY_MAP[rawKey]) { const targetButton = rootSelectorDiv.querySelector(`.root-button[data-note-name="${ROOT_NOTE_KEY_MAP[rawKey]}"]`);
                 targetButton?.classList.remove('keyboard-active'); }
        }

        function setKeyEditMode(newState) {
            isKeyEditMode = newState;
            const container = document.querySelector('.piano-container');
            const btn = document.getElementById('toggle-key-edit-btn');
            container.classList.toggle('key-edit-mode-off', !isKeyEditMode);
            btn.textContent = `Key Edit: ${isKeyEditMode ? 'On' : 'Off'}`;
            btn.classList.toggle('active', isKeyEditMode);
            // Re-render keys to apply draggable attribute and show/hide placeholders
            createPianoKeysAndRootSelector();
        }
        function toggleKeyEditMode() { setKeyEditMode(!isKeyEditMode); }

        function setRowStagger(newState) {
            areRowsStaggered = newState;
            const container = document.getElementById('piano-keys-container');
            const btn = document.getElementById('toggle-row-stagger-btn');
            container.classList.toggle('staggered-rows', areRowsStaggered);
            btn.textContent = `Stagger: ${areRowsStaggered ? 'On' : 'Off'}`;
            btn.classList.toggle('active', areRowsStaggered);
        }
        function toggleRowStagger() { setRowStagger(!areRowsStaggered); }

        function muteAll() {
            Object.keys(activeOscillators).forEach(id => stopSound(id, 0.01));
            if (isArpeggioActive) stopArpLoop();
            stopActiveChordSounds();
            document.querySelectorAll('.piano-key.playing, .piano-key.keyboard-playing, .piano-key.chord-playing').forEach(k => {
                k.classList.remove('playing', 'keyboard-playing', 'chord-playing');
            });
        }

        function updatePitchShiftUI() {
            if (pitchShiftSlider) {
                pitchShiftSlider.value = globalPitchShiftSemitones;
            }
            if (pitchShiftDisplay) {
                pitchShiftDisplay.textContent = `${globalPitchShiftSemitones.toFixed(2)} st`;
            }
        }

        function updateAllActiveNotePitches() {
            const now = audioContext.currentTime;
            const pitchShiftFactor = Math.pow(2, globalPitchShiftSemitones / 12);
            for (const soundId in activeOscillators) {
                const soundObject = activeOscillators[soundId];
                if (soundObject && soundObject.baseFrequency && soundObject.oscillator) {
                    const newFreq = soundObject.baseFrequency * pitchShiftFactor;
                    soundObject.oscillator.frequency.cancelScheduledValues(now);
                    soundObject.oscillator.frequency.linearRampToValueAtTime(newFreq, now + 0.01);
                }
            }
        }

        function setupExtraUIControls() {
            skinSelect = document.getElementById('skin-select');
            keyShapeSelect = document.getElementById('key-shape-select');
            edoInput = document.getElementById('edo-input');
            applyTuningBtn = document.getElementById('apply-edo-btn');
            const dynamicRootBtn = document.getElementById('toggle-dynamic-root-btn');

            document.getElementById('toggle-key-edit-btn')?.addEventListener('click', toggleKeyEditMode);
            document.getElementById('toggle-row-stagger-btn')?.addEventListener('click', toggleRowStagger);
            document.getElementById('mute-all-btn')?.addEventListener('click', muteAll);

            if (skinSelect) skinSelect.addEventListener('change', (e) => applySkin(e.target.value));
            if (keyShapeSelect) keyShapeSelect.addEventListener('change', (e) => applyKeyShape(e.target.value));
            if (applyTuningBtn) applyTuningBtn.addEventListener('click', handleApplyEdoOrJi);
            if (dynamicRootBtn) dynamicRootBtn.addEventListener('click', () => {
                isRootDynamic = !isRootDynamic;
                dynamicRootBtn.textContent = `Root: ${isRootDynamic ? 'Dynamic' : 'Static'}`;
                dynamicRootBtn.classList.toggle('active', isRootDynamic);
                if (!isRootDynamic) {
                    // Reset to original master tuning when switching back to static
                    rootNoteRatios = [...masterRootNoteRatios];
                    recalculateBaseFrequencies();
                    updateRootTuningInputs();
                    selectRootNote(currentRootNoteName); // Re-select to apply static freq
                }
            });
        }
        
        function applySkin(skinClassName) {
            document.body.className = skinClassName;
            currentSkin = skinClassName;
        }

        function applyKeyShape(shapeClassName) {
            const container = document.getElementById('piano-keys-container');
            if (container) {
                container.className = 'piano-keys-container'; // Reset classes
                container.classList.add(shapeClassName);
                if (areRowsStaggered) container.classList.add('staggered-rows');
            }
            currentKeyShape = shapeClassName;
            applyZoom(zoomSlider.value); // Re-apply zoom to recalculate shape sizes
        }

        function handleApplyEdoOrJi() {
            if (isEdoModeActive) {
                // --- Apply JI Logic (revert root system) ---
                masterRootNoteRatios = [...JUST_INTONATION_RATIOS];

                // Recalculate current root ratios based on dynamic mode
                rootNoteRatios = [...masterRootNoteRatios]; 
                if (isRootDynamic) {
                    const rootIndex = NOTE_NAMES.indexOf(currentRootNoteName);
                    if (rootIndex !== -1) {
                        const rootRatio = masterRootNoteRatios[rootIndex];
                        rootNoteRatios = masterRootNoteRatios.map(r => r / rootRatio);
                    }
                }
                
                recalculateBaseFrequencies();
                updateRootTuningInputs();
                selectRootNote(currentRootNoteName); // This re-selects and updates displays

                applyTuningBtn.textContent = 'Apply EDO';
                isEdoModeActive = false;
                alert('Just Intonation root system restored.');

            } else {
                // --- Apply EDO Logic ---
                const edoValue = parseInt(edoInput.value, 10);
                if (isNaN(edoValue) || edoValue < 1 || edoValue > 100) {
                    alert("Please enter a valid EDO value (1-100).");
                    return;
                }

                const newMasterRatios = [];
                for (let i = 0; i < 12; i++) {
                    newMasterRatios.push(Math.pow(2, i / edoValue));
                }
                masterRootNoteRatios = newMasterRatios;
                
                rootNoteRatios = [...masterRootNoteRatios]; 
                if (isRootDynamic) {
                    const rootIndex = NOTE_NAMES.indexOf(currentRootNoteName);
                    if (rootIndex !== -1) {
                        const rootRatio = masterRootNoteRatios[rootIndex];
                        rootNoteRatios = masterRootNoteRatios.map(r => r / rootRatio);
                    }
                }
                
                for (let i = 0; i < NUM_PIANO_KEYS; i++) {
                    if (keysData[i]) { 
                        const ratio = Math.pow(2, i / edoValue);
                        keysData[i].interval = decimalToFractionString(ratio);
                    }
                }

                recalculateBaseFrequencies();
                updateRootTuningInputs();
                selectRootNote(currentRootNoteName);

                applyTuningBtn.textContent = 'Apply JI';
                isEdoModeActive = true;
                alert(`${edoValue}-EDO tuning applied to the root note system and all key slots!`);
            }
        }


        document.addEventListener('DOMContentLoaded', async () => {
            octaveUpBtn = document.getElementById('octave-up-btn'); octaveDownBtn = document.getElementById('octave-down-btn');
            octaveDisplaySpan = document.getElementById('octave-display'); numPianoKeysInput = document.getElementById('num-piano-keys-input');
            applyPianoKeysBtn = document.getElementById('apply-piano-keys-btn');
            maxKeysPerRowInput = document.getElementById('max-keys-per-row-input');
            applyMaxKeysRowBtn = document.getElementById('apply-max-keys-row-btn');
            pitchShiftSlider = document.getElementById('pitch-shift-slider');
            pitchShiftDisplay = document.getElementById('pitch-shift-display');

            setupExtraUIControls();

            await initAudioContext(); 
            setupGlobalAudioControls(); 
            setupMIDI();
            recalculateBaseFrequencies();
            generateRootTuningControls();
            
            if(numPianoKeysInput) numPianoKeysInput.value = NUM_PIANO_KEYS;
            if(maxKeysPerRowInput) maxKeysPerRowInput.value = currentMaxKeysPerRow;
            
            resizeKeyDataArray(); 
            const firstValidKeyIndex = keysData.findIndex(k => k !== null);
            SEQ_ROW_KEY_INDICES = Array(NUM_SEQ_MELODIC_ROWS).fill(firstValidKeyIndex !== -1 ? firstValidKeyIndex : 0);

            if(applyPianoKeysBtn) applyPianoKeysBtn.addEventListener('click', handleApplyPianoKeys);
            if(applyMaxKeysRowBtn) applyMaxKeysRowBtn.addEventListener('click', handleApplyMaxKeysPerRow);

            createPianoKeysAndRootSelector(); 
            setupChordControls(); 
            createSequencerGrid(); 
            setupSequencerControls(); 
            
            updateOctaveDisplay(); 
            if(zoomSlider) {
                zoomSlider.addEventListener('input', (event) => applyZoom(event.target.value));
                applyZoom(zoomSlider.value);
            }
            if(pitchShiftSlider) {
                 pitchShiftSlider.addEventListener('input', (e) => {
                    globalPitchShiftSemitones = parseFloat(e.target.value);
                    updatePitchShiftUI();
                    updateAllActiveNotePitches();
                });
            }
            octaveUpBtn?.addEventListener('click', async () => { await initAudioContext(); if (currentOctaveOffset < MAX_OCTAVE_OFFSET) { currentOctaveOffset++; updateOctaveDisplay(); }});
            octaveDownBtn?.addEventListener('click', async () => { await initAudioContext(); if (currentOctaveOffset > MIN_OCTAVE_OFFSET) { currentOctaveOffset--; updateOctaveDisplay(); }});
            
            document.addEventListener('keydown', handleDocumentKeyDown); 
            document.addEventListener('keyup', handleDocumentKeyUp);
            
            const startAudioOnFirstInteraction = async () => { 
                await initAudioContext(); 
                document.body.removeEventListener('click', startAudioOnFirstInteraction); 
                document.body.removeEventListener('touchstart', startAudioOnFirstInteraction); 
            };
            document.body.addEventListener('click', startAudioOnFirstInteraction, { once: true }); 
            document.body.addEventListener('touchstart', startAudioOnFirstInteraction, { once: true });
        });
    </script>
</body>
</html>
